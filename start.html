<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Tecnologías de Producción de Software</title>
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/white.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/vs2015.css" />
    <link rel="stylesheet" href="./_assets/node_modules/reveal.js-copycode/plugin/copycode/copycode.css" />
    <link rel="stylesheet" href="./_assets/src/css/styles.css" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section  data-markdown><script type="text/template">
### Tecnologías de Producción de Software

<img class="main" height="250px" src="static/logo.svg" />

# Ruby

<div class="container">
  <div class="col">
    <a href="https://www.info.unlp.edu.ar">
    <img class="main" height="100px" src="static/info-unlp.png" />
    </a>
  </div>
  <div class="col">
    <a href="https://www.unlp.edu.ar">
    <img class="main" height="100px" src="static/unlp.svg" />
    </a>
  </div>
</div></script></section><section ><section data-markdown><script type="text/template">
# Presentación</script></section><section data-markdown><script type="text/template">## La cátedra 

| Profesor | Contacto |
| ---- | --- |
| Lic. Christian A. Rodríguez | [![car@info.unlp.edu.ar](static/mail.svg)](mailto:car@info.unlp.edu.ar "car@info.unlp.edu.ar")<!-- .element: class="social"--> [![twitter](static/twitter.svg)](https://twitter.com/car_unlp "twitter")<!-- .element: class="social"--> [![github](static/github.svg)](https://github.com/chrodriguez "github")<!-- .element: class="social"--> | 

| Jefe de Trabajos Prácticos | Contacto |
| ---- | --- |
| Lic. Nahuel Cuesta Luengo | [![ncuesta@cespi.unlp.edu.ar](static/mail.svg)](mailto:ncuesta@cespi.unlp.edu.ar "ncuesta@cespi.unlp.edu.ar")<!-- .element: class="social"--> [![twitter](static/twitter.svg)](https://twitter.com/ncuestal "twitter")<!-- .element: class="social"--> [![github](static/github.svg)](https://github.com/ncuesta "github")<!-- .element: class="social"--> |

| Ayudantes | Contacto |
| ---- | --- |
|Lic. Patricio Mac Adden | [![patriciomacadden@gmail.com](static/mail.svg)](mailto:patriciomacadden@gmail.com "patriciomacadden@gmail.com")<!-- .element: class="social"--> [![twitter](static/twitter.svg)](https://twitter.com/maxawen "twitter")<!-- .element: class="social"--> [![github](static/github.svg)](https://github.com/patriciomacadden "github")<!-- .element: class="social"--> | 
| Damián Candia | [![dcandia@cespi.unlp.edu.ar](static/mail.svg)](mailto:dcandia@cespi.unlp.edu.ar "dcandia@cespi.unlp.edu.ar")<!-- .element: class="social"--> |
</script></section><section data-markdown><script type="text/template">## Horarios de cursada

| Día | Hora | Aula |
| --- | --- | --- |
| Martes | 11 a 13 | 10-A |
| Jueves | 11 a 13 | 10-A |
</script></section><section data-markdown><script type="text/template"><!-- .slide: data-auto-animate -->
## Programa

Dividimos el programa en cuatro secciones principales:

* **Introducción**
* **El lenguaje**
* **Gemas**
* **Rails**</script></section><section data-markdown><script type="text/template"><!-- .slide: data-auto-animate -->
## Programa

* **Introducción**
  * Se realiza un recorrido rápido acerca de la historia del
  lenguaje.
  * Con ejemplos, mostramos el potencial del lenguaje.
  * Presentamos las diferentes implementaciones de ruby y su instalación.
* **El lenguaje**
* **Gemas**
* **Rails**</script></section><section data-markdown><script type="text/template"><!-- .slide: data-auto-animate -->
## Programa

* **Introducción**
* **El lenguaje**: en esta sección profundizamos sobre el lenguaje:
  * Objetos, arreglos, hashes, símbolos, tipos estándar
  * Estructuras de control
  * Bloques e iteradores
  * E/S estandar
  * Clases de objetos, métodos y variables
  * Módulos y mixins
* **Gemas**
* **Rails**</script></section><section data-markdown><script type="text/template"><!-- .slide: data-auto-animate -->
## Programa

* **Introducción**
* **El lenguaje**
* **Gemas:** a las librerias que extienden Ruby se las llaman Gemas. En esta sección
abordaremos:
  * Manejo de dependencias
  * Bundler
* **Rails**
</script></section><section data-markdown><script type="text/template"><!-- .slide: data-auto-animate -->
## Programa

* **Introducción**
* **El lenguaje**
* **Gemas**
* **Rails:** el framework más utilizado por los desarrolladores Ruby. En esta sección
aprenderemos a trabajar con este framework:
  * Conceptos básicos
  * Ruteo
  * ActiveRecord
  * Unit Testing
  * MVC</script></section><section data-markdown><script type="text/template">## Modalidad de cursada

* **Aprobación de la cursada:** 
  * Una **evaluación o entrega** (estamos definiendo el mejor criterio
    de evaluación) para cada tema. En caso de no
    aprobar algún tema, se podrá reiterar la evaluación de aquellos temas no
    aprobados.
  * **Trabajo práctico final integrador**
* La nota final de la materia será un **seis aprobando la cursada**. Será
  posible mejorar la nota con una extensión del trabajo práctico integrador o
  propuesta de trabajo conjunta con el profesor.
</script></section><section data-markdown><script type="text/template">## Bibliografía / Recursos
A medida que se presenten los temas se indicarán las fuentes apropiadas



<small>

Todo el material se encuentra bajo licencia **Creative Commons**

<span xmlns:dct="https://purl.org/dc/terms/" property="dct:title">TTPS - Opcion Ruby</span> por 
<span xmlns:cc="https://creativecommons.org/ns#" property="cc:attributionName">Christian A. Rodriguez</span> se encuentra bajo
una <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/3.0/deed.es">Licencia Creative Commons Atribución-NoComercial-CompartirIgual 3.0 Unported</a>.
<br />
<a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/3.0/deed.es">
<img alt="Licencia Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a>

<div>Icons made by <a href="https://www.flaticon.com/authors/pixel-perfect" title="Pixel perfect">Pixel perfect</a> from <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com</a></div>

</small>


</script></section></section><section  data-markdown><script type="text/template">
# Introducción

<div class="main-list">

* historia
* el lenguaje
* interpretes
</div>
</script></section><section ><section data-markdown><script type="text/template">
# Historia

<div class="main-list">

* introducción
</div></script></section><section data-markdown><script type="text/template">## [Yukihiro Matsumoto](https://en.wikipedia.org/wiki/Yukihiro_Matsumoto)


<div class="container small">
  <div class="col">

  ![Yukihiro Matsumoto](static/yukihiro-matsumoto.jpg)<!-- .element: class="shade" -->

  </div>
  <div class="col">

  ![Ruby](static/logo.svg)<!-- .element: height="80px" -->
  * En japonés: 松本行弘 (まつもとゆきひろ)
  * Matz más simple
  * Empezó el desarrollo de Ruby en 1993
  * En 1995 lanzó la primera versión
  * Aún lidera el desarrollo de Ruby
  </div>
</div>

<small>

## Su célebre frase

  Ruby is designed to make programmers **HAPPY**

</small>
</script></section><section data-markdown><script type="text/template"><!-- .slide: data-auto-animate -->
## ¿Cómo surge Ruby?

* Fusión de lenguajes
  * Smalltalk
  * Perl
  * LISP
* Hasta el 2001 conocido sólo en Japón
  * El libro [Programming Ruby](https://pragprog.com/book/ruby/programming-ruby) fue el 
    impulsor del lenguaje fuera de Japón
  * También conocido como PickAxe
  * La primera versión puede [leerse en línea](https://ruby-doc.org/docs/ProgrammingRuby/)
</script></section><section data-markdown><script type="text/template"><!-- .slide: data-auto-animate -->
## ¿Cómo surge Ruby?

![pickaxe](static/pickaxe.jpg)<!-- .element: class="shade" height="500px" -->
</script></section><section data-markdown><script type="text/template">## [David Heinemeier Hansson](https://en.wikipedia.org/wiki/David_Heinemeier_Hansson)

<div class="container small">
  <div class="col">

![DHH](static/dhh.jpg)<!-- .element: class="shade"-->

  </div>
  <div class="col">

![Rails](static/rails.svg)<!-- .element: height="80px" -->

  * Creador de [Rails](https://rubyonrails.org/): _framework open source para desarrollo de aplicaciones web_
  * Su primer versión liberada (1.0) fue en 2005

  </div>
</div>



</script></section></section><section ><section data-markdown><script type="text/template">
# El lenguaje

<div class="main-list">

* introducción
</div>
</script></section><section data-markdown><script type="text/template"># El lenguaje

* Dinámico
* Sintaxis concisa y expresiva 
* Orientado a objetos
* Capacidades de metaprogramación
* Características funcionales
</script></section><section data-markdown><script type="text/template">## Sintaxis y convenciones

Nombres válidos y convenciones:

```ruby
  NombreDeClaseOModulo
  CONSTANTE
  @nombre_de_atributo
  @@atributo_de_clase
  $variable_global
  nombre_de_metodo
  metodo_peligroso!
  metodo_que_pregunta?
```
</script></section><section data-markdown><script type="text/template">## Objetos

Todos los valores son **objetos**

```ruby
"Aprendiendo ruby".length
"Aprendiendo ruby".each_char.sort.join
1 + 2
1.send :+, 2
```
## Arreglos

```ruby
["Go", "Ruby", "Java", "Python", "PHP", "Javascript"].sort
([1,2,3] + [4,5,6]).last
```
</script></section><section data-markdown><script type="text/template">

## Números

```ruby
-100.abs
1_123_456 * 1_000_000
1.5 * 3
0b1000_1000   # Binario     =>  136
010           # Octal       =>    8
0x10          # Hexadecimal =>   16
```

<div class="container">
  <div class="col">

### nil

```ruby
a = Array.new
a[10].nil?
nil.nil?
```

  </div>
  <div class="col">

### object id

```ruby
1.object_id
nil.object_id
```
  </div>
</div></script></section><section data-markdown><script type="text/template">
## Strings

<div class="container">
  <div class="col">

### Literales

```ruby
'sin interpolar'
"Interpolando: #{'Ja'*3}!"

# Notación alternativa
%q/Hola/
%q!Chau!
%Q{Interpolando: #{3+3}}
```
  </div>
  <div class="col">

### Here document

```ruby
un_string = <<-EOS
  Este es un texto
  de mas de una linea
  que termina aqui.
  Se puede observar que
  espacios antes de cada
  linea.
EOS

un_string.upcase
```
  </div>
</div>
</script></section><section data-markdown><script type="text/template">## Símbolos

* Son como variables prefijados con **:** (dos puntos)
  * Ejemplos: `:action`, `:line_items`, `:+`
* No es necesario declararlos 
* Se garantiza que son únicos
  * No es necesario asignarles ningún valor

```ruby

:uno.object_id  # siempre devolverá lo mismo
"uno".object_id # siempre devolverá diferente

```</script></section><section data-markdown><script type="text/template">## Colecciones

<div class="container small">
  <div class="col">

### Arreglos

```ruby

['Hola', 'Chau']

# sin interpolar
%w(Hola Chau #{2+2})

# interpolando
%W(Hola Chau #{2+2})

[1,2,3,4]
```

  </div>
  <div class="col">


### Hashes

```ruby
# Versión 1.8
{
  :nombre   => 'Christian',
  :apellido   => 'Rodriguez'
}
# Versión > 1.8
{
  nombre:   'Christian',
  apellido:   'Rodriguez'
}
```

  </div>
</div>
</script></section><section data-markdown><script type="text/template">## Expresiones regulares

```ruby
/^[a-zA-Z]+$/
"Do you like cats?" =~ /like/
"192.168.0.10" =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/
```


> Explicación en [Pickaxe](https://ruby-doc.com/docs/ProgrammingRuby/html/intro.html#S5).
> Con [Rubular](https://rubular.com/) es posible probarlas.</script></section><section data-markdown><script type="text/template"><div class="container small">
  <div class="col">

## Rangos

```ruby

0..1
0..10
"a".."z"
"a"..."z"

# Pueden convertirse en arreglos
("a"..."z").to_a

# Rangos como intervalos
(1..10) === 5     # => true
(1..10) === 15    # => false
(1..10) === 3.1   # => true

```

  </div>
  <div class="col">

## Expresiones

```
a = 3.14 # => 3.14

# Veamos el case
estado = nil
face =  case estado
        when "Feliz"  then ":)"
        when "Triste" then ":("
        else               ":|"
end

```


> En Ruby toda expresión retorna un valor 

  </div>
</div>
</script></section><section data-markdown><script type="text/template">
<div class="container small">
  <div class="col">

## Lambdas

```ruby
uno = lambda { |n| n * 2 }
dos = ->(n, m){ n * 2 + m }
tres  = ->(n, m=0){ n * 2 + m}

# Entonces

uno.call 2      # => 4
dos.call 2,3    # => 7
tres.call 2     # => 4
```
  </div>
  <div class="col">

## Bloques


```ruby
3.times do |i|
  puts i
end

3.times { |i| puts i }
```

> Rara vez usaremos un for / while

  </div>
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: data-auto-animate -->
## Ejemplos de bloques y colecciones


<pre data-id="code-animation"><code class="ruby hljs" data-trim data-line-numbers>
# Selección de números pares
(1..10).select { |n| n.even? }

# Procesar cada elemento de una colección
(1..10).map { |n| n*2 }

# Calcular con los elementos de la colección:
(1..100).reduce { |sum,n| sum + n }
</code></pre>


</script></section><section data-markdown><script type="text/template"><!-- .slide: data-auto-animate -->
## Ejemplos de bloques y colecciones

<pre data-id="code-animation"><code class="ruby hljs" data-trim data-line-numbers="3,4,8,9,13,14">
# Selección de números pares
(1..10).select { |n| n.even? }
# o lo que es igual:
(1..10).select(& :even?)

# Procesar cada elemento de una colección
(1..10).map { |n| n*2 }
# o lo que es igual:
(1..10).collect { |n| n*2 }

# Calcular con los elementos de la colección:
(1..100).reduce { |sum,n| sum + n }
# o lo que es igual:
(1..100).reduce(:+)
</code></pre>
</script></section><section data-markdown><script type="text/template">## Bloques y archivos

```ruby

File.open('/etc/passwd').each do |line|
  puts line if line =~ /root/
end
```


</script></section></section><section ><section data-markdown><script type="text/template">
# Intérpretes

<div class="main-list">

* introducción
</div>
</script></section><section data-markdown><script type="text/template">
Ruby como lenguaje, tiene varias implementaciones. La implementación de
referencia es conocida como **MRI: _Matz’s Ruby Interpreter_** o **CRuby**
(porque está desarrollada en C), pero existen otras implementaciones.
</script></section><section data-markdown><script type="text/template">
## MRI

* **Homepage:** https://www.ruby-lang.org/
* Matz' Ruby Implementation
* También llamada CRuby
* Es la implementación de referencia del lenguaje
* Versiones
  * **1.8.x**
  * **1.9.x**
  * **2.x**
  * Ruby 3 will be 3 times faster <!-- .element: class="fragment" -->
</script></section><section data-markdown><script type="text/template">## JRuby


* **Homepage:** https://www.jruby.org/
* Ruby en la **JVM de Java**
* Es la alternativa más madura a MRI en términos de compatibilidad con MRI
* Ventajas:
  * Concurrencia real
  * Interoperabilidad con librerías Java

<img src="static/jruby.png" height="200" />
</script></section><section data-markdown><script type="text/template">## Rubinius

* **Homepage:** https://github.com/rubinius/rubinius
* Comenzó como un experimento que comenzó como una implementación de Ruby, pero
  en realidad apunta a extender las limitaciones de Ruby.
* Su diseño se enfoca en la concurrencia.
* La VM fue escrita en C++
</script></section><section data-markdown><script type="text/template">## TruffleRuby

* **Homepage:** https://github.com/oracle/truffleruby
* Es una implementación de alta performance de Ruby creada por Oracle.
* Permite correr código en paralelo y el startup de aplicaciones ruby es mucho
  menor.
* Basado en [GraalVM](http://graalvm.org/). 

<img src="static/truffleruby.png" height="200" /></script></section><section data-markdown><script type="text/template">## ¿Cómo trabajar con ruby?

* Mayormente la gestión del ambiente de trabajo con ruby se realiza con alguna
  de las siguientes herramientas:
  * [**RVM:** Ruby Version Manager](https://rvm.io/)
  * [**rbenv:** Ruby environment](https://github.com/rbenv/rbenv)
  * _Ruby instalado como paquete del propio sistema no es recomendado._

> El uso, instalación y manejo de los entornos serán abordados en el espacio de
> las prácticas




</script></section></section><section  data-markdown><script type="text/template">
# Ruby

<div class="main-list">

* objetos y atributos
* clases y variables
* colecciones
* bloques e iteradores
* módulos
* excepciones
* conceptos avanzados
</div>
</script></section><section ><section data-markdown><script type="text/template">
# Objetos y atributos

<div class="main-list">

* ruby

</div>
</script></section><section data-markdown><script type="text/template">## Aprendemos con un ejemplo

* Sistema que realiza control de stock de libros.
* Utilizando un lector de código de barra se lee de cada libro información que
  luego se descargará como CSV
* Ejemplo del CSV:

```csv
"Date","ISBN","Amount"
"2008-04-12","978-1-9343561-0-4",39.45
"2008-04-13","978-1-9343561-6-6",45.67
"2008-04-14","978-1-9343560-7-4",36.95
```
</script></section><section data-markdown><script type="text/template">## ¿Qué debe hacer el sistema?

* Leer varios archivos CSV y determinar cuántos ejemplares de cada
  título disponemos
* Determinar además el monto total en libros que tenemos
</script></section><section data-markdown><script type="text/template">## Creamos la clase BookInStock


```ruby
class BookInStock
end
```
> Recordamos que los nombres de las clases deben comenzar con mayúsculas, los
métodos con minúscula

<div class="fragment" >

### Lo probamos

```ruby
a_book = BookInStock.new
another_book = BookInStock.new
```
</div>
</script></section><section data-markdown><script type="text/template">## Observaciones

* Se crean dos objetos diferentes de la clase `BookInStock`. 
* Podríamos decir en esta primer instancia que son el mismo libro, o iguales porque **nada los
distingue**.
* Lo solucionamos obligando que la inicialización indique aquellos datos que distinga al
libro.
</script></section><section data-markdown><script type="text/template">
## Variables de instancia

```ruby
class BookInStock
  def initialize(isbn, price)
    @isbn = isbn
    @price = Float(price)
  end
end
```

* El método `initialize` es especial en Ruby 
* Cuando se invoca el método `new`, Ruby aloca memoria para alojar un objeto no
  inicializado y luego invoca al método `initialize` **pasándole cada parámetro
  que fue enviado a `new`**.
* Entonces `initialize` nos permite configurar el estado inicial de nuestros objetos.
</script></section><section data-markdown><script type="text/template">## En el método initialize

* Se utilizan variables de instancia: comienzan con **@**.
* Las variables `@isbn` e `isbn` son diferentes.
* Se realiza una pequeña validación implícita:
  * El método [`Float`](http://www.ruby-doc.org/core-2.0.0/Kernel.html#method-i-Float)
    toma un argumento y lo convierte a `float`, terminando el programa si falla
    la conversión</script></section><section data-markdown><script type="text/template">
## Usamos los nuevos objetos

```ruby
b1 = BookInStock.new("isbn1", 3)
p b1
b2 = BookInStock.new("isbn2", 3.14)
p b2
b3 = BookInStock.new("isbn3", "5.67")
p b3
```

> Usamos el método `p` porque imprime el estado interno de los objetos.
> Si se utilizara `puts` entonces se invocaría `to_s` e imprimiría:
> `#<nombre_de_clase:id_objeto_en_hex>`
</script></section><section data-markdown><script type="text/template">
## Implementamos to_s

```ruby
class BookInStock
  def to_s
    "ISBN: #{@isbn}, price: #{@price}"
  end
end
```

> Probar nuevamente `puts b3`</script></section><section data-markdown><script type="text/template">## Objetos y sus atributos

* Un objeto como el mostrado anteriormente no permite que nadie acceda a sus
  variables.
* Si bien es algo positivo encapsular, si no permitimos acceder a los datos que
  mantienen el estado del objeto, el mismo se vuelve inútil.
* A las *ventanas* de acceso a los objetos las denominaremos **atributos**.
* Modificaremos nuestra clase de `BookInStock` con el fin de agregar atributos
  para `isbn` y `price` así podemos contabilizarlos.
</script></section><section data-markdown><script type="text/template">## Getters

```ruby
class BookInStock
  def isbn
    @isbn 
  end

  def price
    @price
  end
end
```
</script></section><section data-markdown><script type="text/template">## Atributos de lectura

A los atributos anteriores se los denomina **accesor** porque mapean
directamente con las variables de instancia. Ruby provee un shortcut: **`attr_reader`**.

```ruby 
class BookInStock
  attr_reader :isbn, :price
  def initialize(isbn, price)
    @isbn = isbn
    @price = Float(price)
  end
end
```

> * Notar que se utilizan **símbolos**.
> * `attr_reader` **no define variables de instancia**, sólo los métodos de acceso.
</script></section><section data-markdown><script type="text/template">## Atributos de escritura

No sólo leemos atributos: a veces necesitamos modificar un valor. Ésto es
posible definiendo un método terminado con **el signo igual**.

```ruby
class BookInStock
  attr_reader :isbn, :price

  def initialize(isbn, price)
    @isbn = isbn
    @price = Float(price)
  end

  def price=(new_price)
    @price = new_price
  end
end
```
</script></section><section data-markdown><script type="text/template">## Atributos de escritura

```ruby
book = BookInStock.new("isbn1", 33.80)
book.price = book.price * 0.75 # discount price
puts "New price = #{book.price}"
```

<div class="container">

<div class="col small">

Podemos usar entonces:
* **`attr_writer`:** acceso W.
* **`attr_accessor`:** acceso RW.

</div>
<div class="col">


```ruby
class BookInStock

  attr_reader :isbn
  attr_accessor :price

  def initialize(isbn, price)
    @isbn = isbn
    @price = Float(price)
  end
end
```

</div>
</div></script></section><section data-markdown><script type="text/template">## Atributos virtuales

Agregamos el precio en centavos

<pre><code class="ruby hljs" data-trim data-line-numbers="10-16">
class BookInStock
  attr_reader :isbn
  attr_accessor :price
  def initialize(isbn, price)
    @isbn = isbn
    @price = Float(price)
  end

  def price_in_cents
    Integer(price*100 + 0.5)
  end

  def price_in_cents=(cents)
    @price = cents / 100.0
  end
end
</pre></code>
</script></section><section data-markdown><script type="text/template">## El lector de CSV
Ya tenemos el objeto que representa un libro. Resta implementar:
* Leer varios archivos CSV
* Totalizar ejemplares iguales
* Totalizar el precio de los libros en stock
</script></section><section data-markdown><script type="text/template">## CsvReader

Pensamos la estructura de `CsvReader`
```ruby
class CsvReader
  def initialize
  end

  def read_in_csv_data(csv_file_name)
  end

  def total_value_in_stock
  end

  def number_of_each_isbn
  end
end
```</script></section><section data-markdown><script type="text/template">## Uso de CsvReader

```ruby
reader = CsvReader.new
reader.read_in_csv_data("file1.csv")
reader.read_in_csv_data("file2.csv")
# Otros csv
puts "Total value in stock =  #{reader.total_value_in_stock}"
```

* Notamos que `CsvReader` debe ir acumulando lo que va leyendo de cada csv.
* Para ello mantendremos un arreglo de valores como variable de instancia.
* Para leer un CSV, Ruby provee de una librería que simplificará el trabajo.
</script></section><section data-markdown><script type="text/template">
## CsvReader

```ruby
require 'csv'

class CsvReader

  def initialize
    @books_in_stock = []
  end

  def read_in_csv_data(csv_file_name)
    CSV.foreach(csv_file_name, headers: true) do |row|
      @books_in_stock << 
        BookInStock.new(row["ISBN"], row["Amount"])
    end
  end
end
```
> Utilizamos la librería `csv` que nos permite acceder a los campos de cada
> columna por su nombre.
</script></section><section data-markdown><script type="text/template">## Cálculo  del precio total

```ruby
class CsvReader

  def total_value_in_stock
    sum = 0.0
    @books_in_stock.each do |book| 
      sum += book.price
    end
    sum
  end

end
```

> Ya veremos una implementación **más rubista** que la utilizada en esta
> instancia.
</script></section><section data-markdown><script type="text/template">
## Organizando el código

* Dividimos el código en tres archivos
  * **`lib/book_in_stock.rb`:** la clase `BookInStock`
  * **`lib/csv_reader.rb`:** el código de `CsvReader`
  * **`stock_stats.rb`:** el programa principal
* Aparecerán dependencias entre ellos
  * Para cargar dependencias externas se utiliza: **`require`** y **`require_relative`**
</script></section><section data-markdown><script type="text/template">
### stock_stats.rb

```ruby
require_relative 'csv_reader'

reader = CsvReader.new
ARGV.each do |csv_file_name|
  STDERR.puts "Processing #{csv_file_name}"
  reader.read_in_csv_data(csv_file_name)
end

puts "Total value = #{reader.total_value_in_stock}"
```

[Descargar el
ejemplo](https://github.com/ttps-ruby/teoria/tree/master/ejemplos/stock-stats)


</script></section></section><section ><section data-markdown><script type="text/template">
# Clases y variables

<div class="main-list">

* ruby

</div>
</script></section><section data-markdown><script type="text/template">
# Clases
</script></section><section data-markdown><script type="text/template">## Control de acceso

* Permitir demasiado acceso en las clases incrementará el **acoplamiento** de
  la aplicación: _los usuarios de una clase que se expone demasiado podrían confiar en
    detalles de implementación en vez de su interfaz lógica._
* Ruby provee control de acceso a los métodos
* Una regla importante es: **_Nunca exponer métodos que puedan dejar un objeto
  en estado inválido_**.
</script></section><section data-markdown><script type="text/template">
## Niveles de protección
* **Públicos:** los métodos públicos pueden invocarse por cualquiera. Los
  métodos son públicos por defecto excepto `initialize` que es privado.
* **Protegidos:** pueden invocarse por objetos de la clase que lo define y
  subclases.
* **Privados:** no pueden ser invocados con un receptor explícito:
  _el receptor es siempre el objeto actual, `self`_. Esto
  significa que tampoco puede invocar el método privado de otra instancia de la
  misma clase.
</script></section><section data-markdown><script type="text/template">## Aplicando accesos

```ruby
class MyClass
  def method  # default is public
  end

  protected   # subsequent methods will be 'protected'
  def method2
  end

  private     # subsequent methods will be 'private'
  def method3
  end

  public      # subsequent methods will be 'public'
  def method4
  end
end
```</script></section><section data-markdown><script type="text/template">## Alternativamente

```ruby
class MyClass
  def method1; end
  def method2; end
  def method3; end
  def method4; end

  public :method1, :method4
  protected :method2
  private :method3
end
```
</script></section><section data-markdown><script type="text/template">
# Variables
</script></section><section data-markdown><script type="text/template">## Variables
* Hemos usado variables en varias oportunidades.
* Se usan para no perder valores y poder referenciarlos nuevamente.
* Cada variable es una **referencia** a un objeto.

> *Is a variable an object?* ***In Ruby, the answer is no.*** *A variable is simply a
> reference to an object. Objects float around in a big pool somewhere (the heap, most of the
> time) and are pointed to by variables.*
</script></section><section data-markdown><script type="text/template">
## Son referencias

Analicemos el siguiente ejemplo

```ruby
person1 = "Tim"
person2 = person1
person1[0] = 'J'
puts "person1 is #{person1}"
puts "person2 is #{person2}"
```

### Para evitarlo: `dup`

```ruby
person1 = "Tim"
person2 = person1.dup
person1[0] = 'J'
puts "person1 is #{person1}"
puts "person2 is #{person2}"
```</script></section><section data-markdown><script type="text/template">
## Freezando un objeto

Es posible freezar objetos

```ruby
person1 = "Tim"
person2 = person1
person1.freeze
person2[0] = 'J'
```



</script></section></section><section ><section data-markdown><script type="text/template">
# Colecciones

<div class="main-list">

* ruby

</div>
</script></section><section data-markdown><script type="text/template">
## Introducción
* Las colecciones representan elementos fundamentales de cualquier programa.
* Ruby provee dos clases que representan colecciones:
  * `array`
  * `hash` _o  arreglo asociativo_
* El correcto uso de estas colecciones es fundamental en la programación Ruby.
* Los bloques, combinados con colecciones se convierten en construcciones muy
  poderosas para la iteración.
</script></section><section data-markdown><script type="text/template">
## Array

<div class="container">
  <div class="col">

* La clase `Array` mantiene una colección de referencias a objetos.
* Cada referencia a objeto ocupa una posición en el arreglo, identificada por un
  índice entero no negativo.

  </div>
  <div class="col">

```ruby
a = [ 3.14159, "pie", 99 ]
a.class
a.length
a[0]
a[1]
a[2]
a[3]

b = Array.new
b.class
b.length
b[0] = "second"
b[1] = "array"
```
  </div>
</div>
</script></section><section data-markdown><script type="text/template">
## Arrays y `[]`

* Los elementos de un arreglo se acceden con el operador `[]`.
* Pero `[]` es un método (de instancia en la clase `Array`) y por tanto puede
  implementarse por cualquier subclase.
* El primer índice de un arreglo es el cero.
* Un arreglo accedido en un índice positivo retorna el objeto referenciado en
  esa posición.
  * Si no hay objeto, retorna `nil`.
* Un arreglo accedido en un índice negativo, retorna el objeto contando desde el
  final.
</script></section><section data-markdown><script type="text/template">## Uso de índices

<div class="container">
  <div class="col">

### Negativos

```ruby
a = [ 1, 7, 9]
a[-1]
a[-2]
a[-99]


```

  </div>
  <div class="col">

### Pares
```ruby
a = [ 1, 3, 5, 7, 9 ]
a[1, 3]
a[3, 1]
a[-3, 2]


```

> El significado es `[desde,cantidad]`

  </div>
  <div class="col">

### Rangos

```ruby
a = [ 1, 3, 5, 7, 9]
a[1..3]
a[1...3]
a[3..3]
a[-3..-1]
```
> Significa **desde** y **hasta**.
> Si se utiliza `..` se incluye el fin de rango, con
> `...` se **excluye** el extremo final.
  </div>
  </div>
</script></section><section data-markdown><script type="text/template">## El método `[]=`


Setea elementos de un array.

```ruby
a = [ 1, 3, 5, 7, 9 ]
a[1] = 'bat'
a[-3] = 'cat'
a[3] = [ 9, 8 ]
a[6] = 99
```

> Si se utiliza un único índice, reemplaza su valor por lo que esté
> a la derecha de la asignación: _cualquier gap que haya quedado luego de `[]=`
> se completa con nil._
</script></section><section data-markdown><script type="text/template">## El método `[]=`
* Utilizando dos valores o un rango, el comportamiento depende de lo que 
  esté a la derecha de la asignación:
  * Si la cantidad  a reemplazar es cero, entonces **inserta el valor**
    en la posición inicial: **_no se eliminan elementos_**.
  * Si el valor a la **derecha es un arreglo**, sus elementos se utilizan en el 
    reemplazo: _el tamaño del arreglo es actualizado si la cantidad de
    elementos a la derecha difiere de la cantidad a reemplazar._
</script></section><section data-markdown><script type="text/template">## Mejor un ejemplo


```ruby
a = [ 1, 3, 5, 7, 9 ]
a[2, 2] = 'cat'
a[2, 0] = 'dog'
a[1, 1] = [ 9, 8, 7 ]
a[0..3] = []
a[5..6] = 99, 98
```
</script></section><section data-markdown><script type="text/template">## push y pop


```ruby
stack = []
stack.push "red"
stack.push "green"
stack.push "blue"

puts stack.pop
puts stack.pop
puts stack.pop
```
</script></section><section data-markdown><script type="text/template">## shift y unshift

```ruby
stack = []
(stack.unshift 1).unshift 2
stack.unshift 3

puts stack.shift
puts stack.shift
puts stack.shift
```
</script></section><section data-markdown><script type="text/template">## first y last

```ruby
array = [ 1, 2, 3, 4, 5, 6, 7 ]
p array.first(4)
p array.last(4)
```
</script></section><section data-markdown><script type="text/template">## Hashes

* Los arreglos se indexan con enteros, los hashes con objetos: _Símbolos, strings, expresiones regulares, etc_.
* Cuando se almacena un valor en un hash, utilizamos:
  * El índice, generalmente llamado *key*
  * El dato a almacenar en dicho índice, generalmente llamado *valor*
* El acceso a los valores referenciados por un hash se realiza por medio de los
  *keys*.
</script></section><section data-markdown><script type="text/template">
### Ejemplo

```ruby
h = { 'dog' => 'canine', 'cat' => 'feline' }
h.length # => 2
h['dog'] # => "canine"
h['cow'] = 'bovine'
h[12] = 'dodecine'
h['cat'] = 99
```
</script></section><section data-markdown><script type="text/template">### Cambio de notación

```ruby
# En ruby >= 1.9
h = { dog: 'canine', cat: 'feline' }

# En ruby < 1.9
h = { :dog => 'canine', :cat => 'feline' }
```</script></section><section data-markdown><script type="text/template">
### Un programa usando colecciones


Calcular el número de veces que aparece una palabra en un texto

> El problema se divide en dos partes:
> * Separar el texto en palabras: *suena como un array*
> * Luego contar cada palabra diferente: *suena como hash*
</script></section><section data-markdown><script type="text/template">
### El método que obtiene las palabras

Usando expresiones regulares y el método `scan` todo parece muy simple:

```ruby
def words_from_string(string)
  string.downcase.scan(/[\w']+/)
end
```

> Analizar otros ejeplos de scan. Por ejemplo probar:
> 
> `"0123456789".scan /.{2}/`</script></section><section data-markdown><script type="text/template">### El método que cuenta las palabras

Con un hash indexaremos para cada palabra, la cantidad de ocurrencias.

```ruby
if counts.has_key?(next_word)
  counts[next_word] += 1
else
  counts[next_word] = 1
end
```
</script></section><section data-markdown><script type="text/template">
## Refactorizamos

```ruby
def count_frequency(word_list)
  counts = Hash.new(0)
  for word in word_list
    counts[word] += 1
  end
  counts
end
```

> `Hash.new` puede recibir como parámetro el valor usado para incializar cada
> valor del Hash.  [Ver ejemplo](https://github.com/ttps-ruby/teoria/tree/master/ejemplos/words-frequency).
> Es importante destacar que el ejemplo incluye tests para analizar cómo
> desarrollar utilzando TDD.


</script></section></section><section ><section data-markdown><script type="text/template">
# Bloques e iteradores

<div class="main-list">

* ruby

</div>
</script></section><section data-markdown><script type="text/template">
## Bloques
* Un bloque es código encerrado entre llaves o las palabras claves `do` y `end`.
* Ambas formas son idénticas, salvo por la precedencia.
  * Cuando el código del bloque entra en una línea usar {}.
  * Cuando tiene más de una línea usar `do` / `end`.
* Los bloques pueden verse como métodos anónimos.
</script></section><section data-markdown><script type="text/template">
## Bloques
* Pueden recibir parámetros, que se explicitan entre barras verticales `|`.
* El código de un bloque no se ejecuta cuando se define, sino que se almacenará
  para ser ejecutado más adelante.
* En ruby, los bloques sólo podrán usarse después de la *invocación* de algún
  método:
  * Si el método recibe parámetros, entonces aparecerá luego de ellos.
  * Podría verse incluso como un parámetro extra que es pasado al método.
</script></section><section data-markdown><script type="text/template">
## Ejemplo

Suma de los cuadrados de los números en un arreglo

<div class="container">
<div class="col">

```ruby
sum = 0
[1, 2, 3, 4].each do |value|
  square = value * value
  sum += square
end
puts sum
```

</div>
<div class="col small">

* El bloque se invoca para cada elemento en el arreglo
* El elemento del arreglo es pasado al bloque en la variable `value`
* La variable `sum` declarada fuera del bloque es actualizada dentro del bloque
</div>
</div>
</script></section><section data-markdown><script type="text/template">## Bloques

* **Regla importante:** *si existe una variable en el bloque con el mismo
  nombre que una variable dentro del alcance pero creada fuera del bloque, ambas serán la
  misma variable. En el ejemplo hay sólo una variable `sum`*
* Veremos que el comportamiento mencionado podremos cambiarlo
* Si una variable aparece sólo en el bloque, entonces será local al mismo (como
`square`)
</script></section><section data-markdown><script type="text/template">## Un caso inesperado

```ruby
# assume Shape defined elsewhere
square = Shape.new(sides: 4) 
#
# .. lots of code
#
sum = 0
[1, 2, 3, 4].each do |value|
  square = value * value
  sum += square
end

puts sum
square.draw # BOOM!
```
</script></section><section data-markdown><script type="text/template">## Mas casos

No sucede lo mismo con los argumentos al bloque

```ruby
value = "some shape"
[ 1, 2 ].each {|value| puts value }
puts value
```

Podemos solucionar el problema de `square`

```ruby
square = "some shape"
sum = 0
[1, 2, 3, 4].each do |value; square|
  square = value * value # different variable
  sum += square
end
puts sum
puts square
```
</script></section><section data-markdown><script type="text/template">## La magia de los bloques

<div class="small">

* Mencionamos que los bloques se utilizan de forma adyacente a la llamada a un
  método y que no se ejecutan en el momento en que aparecen en el código.
* Para lograr este comportamiento, dentro de un método cualquiera, podremos
  invocar un bloque:
  * Los bloques se invocarán como si fueran métodos.
  * Para invocar un bloque se utiliza la sentencia `yield`.
  * Al invocar `yield` ruby invocará al código del bloque .
  * Cuando el bloque finaliza, ruby devuelve el código inmediatamente al
    finalizar el llamado a `yield`.
</div></script></section><section data-markdown><script type="text/template">## Ejemplo de un bloque

```ruby

def three_times
  yield
  yield
  yield
end

three_times { puts "Hola" }
```
</script></section><section data-markdown><script type="text/template">
## Parámetros a un bloque

* Cuando utilizamos `yield` podemos enviarle un parámetro
  * El parámetro enviado se mapea con el definido en el bloque entre las barras
    verticales.
* Un bloque puede retornar un valor y ser usado en el método.
</script></section><section data-markdown><script type="text/template">## Ejemplo de envío de parámetros

```ruby

def fib_up_to(max)
  i1, i2 = 1, 1
  while i1 <= max
    yield i1
    i1, i2 = i2, i1+i2
  end
end

fib_up_to(1000) {|f| print f, " " }

```
</script></section><section data-markdown><script type="text/template">## Uso del valor retornado

```ruby

class Array
  def my_find
    for i in 0...size
      value = self[i]
      return value if yield(value)
    end
    return nil
  end
end

(1..200).to_a.my_find {|x| x%5 == 0}

(1..200).to_a.my_find {|x| x == 0}

```
</script></section><section data-markdown><script type="text/template">## Los iteradores
* Las clases que implementan colecciones, como `Array` *hacen lo que hacen
  mejor:*
  * Acceder a los elementos que contienen.
* El comportamiento de qué hacer con cada elemento lo delegan a la aplicación:
  * Permitiendo que nos concentremos sólo en un requerimiento particular.
  * En los casos anteriores (`find`), sería encontrar un elemento para el cual
    el criterio sea verdadero.
</script></section><section data-markdown><script type="text/template">## each y collect

* El iterador `each` es el más simple.
  * Solo invoca `yield` para cada elemento.
* El iterador `collect` también conocido como `map`.
  * Invoca `yield` para cada elemento. El resultado lo guarda en un nuevo 
  arreglo que es **retornado**.

```ruby
[ 1, 3, 5, 7, 9 ].each {|i| puts i }

['k','h','m','t','w'].collect {|x| x.succ }
```
</script></section><section data-markdown><script type="text/template">## Otros usos de iteradores 

* Los iteradores no sólo se usan con array y hash.
* Su lógica es muy utilizada en clases de entrada / salida para retornar
  líneas sucesivas o bytes.

```ruby
f = File.open("testfile")
f.each { |line| puts "The line is: #{line}"}
f.close
```


```ruby
f = File.open("testfile")
f.each_with_index do |line, index| 
  puts "Line #{index} is: #{line}" 
end
f.close
```
</script></section><section data-markdown><script type="text/template">## inject
* Este iterador tiene un nombre *raro*.
* Permite acumular un valor a lo largo de los miembros de una colección.
* Recibe un parámetro que es el valor inicial para comenzar a acumular.
  * Si no se especifica **toma el primer elemento de la colección**.

```ruby
[1,3,5,7].inject(0) {|sum, element| sum+element}
[1,3,5,7].inject    {|sum, element| sum+element}
[1,3,5,7].inject(1) {|prod, element| prod*element}
[1,3,5,7].inject    {|prod, element| prod*element}
```
</script></section><section data-markdown><script type="text/template">## inject

Un uso más críptico de `inject`:

```ruby
[1,3,5,7].inject(:+)
[1,3,5,7].inject 100, :+
[1,3,5,7].inject(:*)
```
</script></section><section data-markdown><script type="text/template">## Problema de iteradores
* Los iteradores son muy cómodos pero:
  * Son parte de la colección y no una clase a parte.
  * En otros lenguajes (como Java), las colecciones no implementan sus
    iteradores, sino que son clases separadas (como por ejemplo la interfaz 
    Iterator de Java).
  * Es complicado iterar dos colecciones simultáneamente.
</script></section><section data-markdown><script type="text/template">## Enumerators

* La solución: clase `Enumerator`.
* Se obtiene de una colección con el método `to_enum` o `enum_for`.

```ruby
a = [ 1, 3, "cat" ]
h = { dog: "canine", fox: "lupine" }
# Create Enumerators
enum_a = a.to_enum
enum_h = h.to_enum
enum_a.next   # => 1
enum_h.next   # => [ :dog, "canine" ]
enum_a.next   # => 3
enum_h.next   # => [ :fox, "lupine" ]
```</script></section><section data-markdown><script type="text/template">## Enumerators e iteradores

Si un iterador se utiliza sin bloque, entonces retorna un Enumerator

```ruby
a = [1,2,3].each
a.next
```
</script></section><section data-markdown><script type="text/template">## El método loop
<div class="small">

* Ejecuta el código que se encuentra dentro del bloque.
* Se puede salir con break cuando se cumple una condición.
* Si hay iteradores, `loop` terminará cuando el Enumerator se quede sin valores.

</div>

<div class="container">
<div class="col">

```ruby


loop { puts "Hola" }



```
</div>
<div class="col">

```ruby
i=0
loop do
  puts i += 1
  break if i >= 10
end
```
</div>
</div>

```ruby
short_enum = [1, 2, 3].to_enum
long_enum = ('a'..'z').to_enum
loop { puts "#{short_enum.next} - #{long_enum.next}" }
```
</script></section><section data-markdown><script type="text/template">## Enumerator como objeto

Sabemos que es posible usar `each_with_index` en `Array`

```ruby
result = []
[ 'a', 'b', 'c' ].each_with_index do |item, index| 
  result << [item, index] 
end
```

<div class="fragment">

¿Y si queremos hacer lo mismo con un `String`?
</div>

<div class="fragment small">

* No existe `each_with_index` en `String`.
* Pero sí existe `each_char` que es como `each` de `Array` pero sobre cada
  caracter del string.
  * Si no enviamos un bloque, retornará un `Enumerator`.
* La interfaz `Enumerable` define el método `each_with_index`.
</div>
</script></section><section data-markdown><script type="text/template">## El código con String
```ruby
result = []
"cat".each_char.each_with_index do |item, index| 
    result << [item, index] 
end
# Aun más simple:
result = []
"cat".each_char.with_index do |item, index| 
    result << [item, index] 
end
```
</script></section><section data-markdown><script type="text/template">## Enumerator como generadores
<div class="small">

* Podemos crear objetos enumerator explícitamente en vez de hacerlo a partir de
  una colección.
* Para ello es necesario utilizar un bloque en la creación:
  * El código del bloque se usará por el objeto Enumerator cada vez que el
    programa principal le solicite un nuevo valor.
  * Este bloque no se ejecutará como otros bloques dado que su ejecución
    se disparará cada vez que se solicita el siguiente valor.
  * La ejecución del bloque se pausa y vuelve al programa principal cuando se
    encuentra `yield`.
  * Cuando se solicita el siguiente valor, el código del bloque continúa a
    partir de la línea siguiente al `yield`.
</div>
</script></section><section data-markdown><script type="text/template">## Enumerator como generadores
Generamos **secuencias infinitas**:


```ruby
fibonacci = Enumerator.new do |caller|
  i1, i2 = 1, 1
  loop do
    caller.yield i1
    i1, i2 = i2, i1+i2
  end
end

6.times { puts fibonacci.next }
```

<div class="small">

Como `Enumerator` es `Enumerable` sería posible:
</div>

```ruby
fibonacci.first(1000).last
```
</script></section><section data-markdown><script type="text/template">## ¡Hay que tener cuidado!

<div class="small">

* Cuidado con los enumerators que generan listas infinitas.
* Los metodos comunes de los enumeradores como `count` y `select` tratarán de
  leer todos los elementos antes de retornar un valor.
  * Podemos escribir la versión de `select` adecuada a nuestra lista
    infinita.

</div>

```ruby
def infinite_select(enum, &block)
  Enumerator.new do |caller|
    enum.each do |value|
      caller.yield(value) if block.call(value)
    end
  end
end

p infinite_select(fibonacci) {|val| val % 2 == 0}.first(5)
```
</script></section><section data-markdown><script type="text/template">## Solución conveniente
Podemos escribir filtros como `infinite_select` directamente en la clase
`Enumerator`

``` ruby
class Enumerator
  def infinite_select(&block)
    Enumerator.new do |caller|
      self.each do |value|
        caller.yield(value) if block.call(value)
      end
    end
  end
end

p fibonacci.
  infinite_select {|val| val % 2 == 0}.
  infinite_select {|val| val.to_s =~ /13\d$/ }.
  first(2)
```
</script></section><section data-markdown><script type="text/template">## Bloques como transacciones

<div class="small">

* Podemos usar bloques para definir código que debe ejecutarse bajo ciertas
  condiciones transaccionales.
* Por ejemplo:
  * Abrir un archivo
  * Procesarlo
  * Cerrarlo
* Si bien esto podemos hacerlo secuencialmente, utilizando bloques simplificamos
  mucho.
</div>

```ruby
class File
  def self.open_and_process(*args)
    f = File.open(*args)
    yield f
    f.close()
  end
end
```
</script></section><section data-markdown><script type="text/template">## Analizamos un poco...

<div class="small">

* El método de clase implementado fue desarrollado para que entienda los mismos
  parámetros que `File.open`.
* Para ello, lo que hicimos es pasar los parámetros tal cual se enviaron a
  `File.open`.
  * Esto se logra definiendo como argumento al método `*args` que significa:
    *tomar todos los argumentos enviados al método actual y colocarlos en un
    arreglo llamado args*.
  * Luego llamamos a `File.open(*args)`. Utilizar *args vuelve a expandir los
    elementos del arreglo a parámetros individuales.
</div>
</script></section><section data-markdown><script type="text/template">## Versión completa de my_open
```ruby
class File
  def self.my_open(*args)
    result = file = File.new(*args)
    if block_given?
      result = yield file
      file.close
    end
    return result
  end
end
```


> Esta técnica es tan útil, que `File.open` ya lo implementa.  Además de usar `File.open`
> para abrir un archivo, podemos usarlo para directamente procesarlo como lo hacíamos
> con `open_and_process`.
</script></section><section data-markdown><script type="text/template">## Bloques como objetos
* Anteriormente mencionamos que los bloques son como un parámetro
  adicional pasado a un método.
* Podremos forzar bloques como parámetros explícitos:
  * Utilizando & en el último parámetro, Ruby buscará el codigo
    de un bloque cuando el método es invocado.
  * Este parámetro podrá utilizarse como cualquier otro.
</script></section><section data-markdown><script type="text/template">## Bloques como objetos

```ruby
class ProcExample
  def pass_in_block(&action)
    @stored_proc = action
  end
  def use_proc(parameter)
    @stored_proc.call(parameter)
  end
end

eg = ProcExample.new
eg.pass_in_block { |param| puts "The parameter is #{param}" }
eg.use_proc(99)
```

> Notar que pasando `&action` podemos almacenar el bloque en una variable. Si no
> se usara `&` no sería posible.</script></section><section data-markdown><script type="text/template">
## Avanzando un poco más...
* Vemos que `call` invoca la ejecución del bloque.
* Muchos programas utilizan esta idea para implementar **callbacks**.
* ¿Qué pasaría si retornamos el bloque?

```ruby
def create_block_object(&block)
  block
end

bo = create_block_object do |param| 
  puts "You called me with #{param}"
end
bo.call 99
bo.call "cat"
```
</script></section><section data-markdown><script type="text/template">## Proc y lambda
* Devolver un bloque es tan útil que en Ruby hay dos formas de hacerlo:
  * `lamda` y `Proc.new` toman un bloque y retornan un objeto.
  * El objeto retornado es de la clase `Proc`.

> Ya hemos mencionado que `lambda` controla los parámetros que requiere el
> bloque  mientras que `Proc` no lo hace.
</script></section><section data-markdown><script type="text/template">## Bloques como Closures
Los bloques pueden utilizar variables que están dentro del alcance del bloque.

```ruby
def n_times(thing)
  lambda {|n| thing * n }
end
p1 = n_times(10)
p1.call(3)
p1.call(4)
p2 = n_times("Hola ")
p2.call(3)
```
> ¿Qué hace el ejemplo anterior?
</script></section><section data-markdown><script type="text/template">## ¿Qué es un Closure?
* El método `n_times` referencia un parámetro `thing` que es usado dentro el bloque.
* Aunque en las llamadas a `call` el parámetro `thing` está fuera del alcance,
  el parámetro se mantiene accesible dentro del bloque.

_**Closure:** variables en el alcance cercano que son referenciadas por el bloque
se mantienen accesibles por la vida del bloque y la vida del objeto Proc creado
para este bloque._
</script></section><section data-markdown><script type="text/template">## Otro ejemplo de Closure

```ruby
def what_do_i_do?
  value = 1
  lambda { value += value }
end

let_me_see = what_do_i_do?
let_me_see.call
let_me_see.call
```
</script></section><section data-markdown><script type="text/template">### Lambda: notación alternativa

```ruby
lambda { |params| ... }
# es equivalente a
->params { ... }

# Y con parámetros
proc1 = -> arg {puts "proc1:#{arg}" }
proc2 = -> arg1, arg2 {puts "proc2:#{arg1} y #{arg2}" }
proc3 = ->(arg1, arg2) {puts "proc3:#{arg1} y #{arg2}" }

proc1.call "ant"
proc2.call "bee", "cat"
proc3.call "dog", "elk"
```
</script></section><section data-markdown><script type="text/template">## Custom while
Reimplementamos un while usando bloques

<div class="container">

<div class="col fragment">

### Proc
```ruby
def my_while(cond, &body)
  while cond.call
    body.call
  end
end

a = 0
my_while(Proc.new { a < 3 }) do
  puts a
  a += 1
end
```
</div>
<div class="col fragment">

### Lamda
```ruby
def my_while(cond, &body)
  while cond.call
    body.call
  end
end

a = 0
my_while -> { a < 3 } do
  puts a
  a += 1
end
```
</div>
</div>
</script></section><section data-markdown><script type="text/template">### Lista de parámetros a un bloque
* Los argumentos a un bloque podrán ser:
  * Argumentos splat.
  * Inicializados con un valor por defecto.
  * Bloques como parámetro (usando `&`).</script></section><section data-markdown><script type="text/template">### Lista de parámetros a un bloque
```ruby
proc1 = lambda do |a, *b, &block|
  puts "a = #{a.inspect}"
  puts "b = #{b.inspect}"
  block.call
end
proc1.call(1, 2, 3, 4) { puts "in block1" }

proc2 = -> a, *b, &block do
  puts "a = #{a.inspect}"
  puts "b = #{b.inspect}"
  block.call
end
proc2.call(1, 2, 3, 4) { puts "in block2" }
```
> Más adelante veremos en detalle cómo funciona el splat.
</script></section><section data-markdown><script type="text/template">### El símbolo usado como bloque

Para entender por qué funciona:

```ruby
[1,2,3].inject &:+
```

<div class="small"> 

Analizando qué es lo que sucede en el siguiente ejemplo
</div>

```ruby
o = Object.new
[1,2,3].inject &o
# TypeError: wrong argument type Object (expected Proc)
```
</script></section><section data-markdown><script type="text/template">### El símbolo usado como bloque

Una solución es implementar `to_proc`:

<div class="container">

<div class="col">

```ruby
class Object
  def to_proc
    Proc.new {}
  end
end
o = Object.new
[1,2,3].inject &o
```

</div>
<div class="col small">

* No falla, pero no hace lo esperado.
* Sólo convertimos a un bloque vacío.
* Un bloque sin acciones no es útil.
* Menos en el contexto de `inject`.
</div>
</div></script></section><section data-markdown><script type="text/template">### El símbolo usado como bloque

<div class="small">

Analizando entonces lo que sucedió inferimos que la clase `Symbol` implementa
`#to_proc` de la siguiente forma:
</div>

<div class="container">
<div class="col">

```ruby
class Symbol
  def to_proc
    lambda { |obj| obj.send(self) }
  end
end
```
</div>
<div class="col">

```ruby

[1,2,3].map &:to_s

[1,2,3].inject &:+


```
</div>
</div>

**¡¡Probemos!!**
<div class="small fragment">

Funciona **`map`** pero no **`inject`**. _Observemos bien el error._
</div></script></section><section data-markdown><script type="text/template">### El símbolo usado como bloque


<div class="small">
Tratamos de solucionar la implementación anterior:
</div>

<div class="container">
<div class="col">

```ruby
class Symbol
  def to_proc
    lambda do |obj, args| 
      obj.send(self, *args)
    end
  end
end
```
</div>
<div class="col">

```ruby

[1,2,3].map &:to_s


[1,2,3].inject &:+



```
</div>
</div>

**¡¡Probemos!!**
<div class="small fragment">

Funciona **`inject`** pero no **`map`**. _Observemos bien el error._
</div>
<div class="small fragment">

> Claro ejemplo de solucionar algo y romper otra cosa. Caso que se controla
> utilizando tests de unidad.
</div></script></section><section data-markdown><script type="text/template">### El símbolo usado como bloque

La solución a ambos problemas:

```ruby
class Symbol
  def to_proc
    lambda { |obj, args=nil| obj.send(self, *args) }
  end
end

[1,2,3].map &:to_s
[1,2,3].inject &:+
```

</script></section></section><section ><section data-markdown><script type="text/template">
# Módulos</script></section><section data-markdown><script type="text/template">## Introducción

* Uno de los principios aceptados sobre buen diseño es la eliminación de
  duplicados innecesarios.
* Trataremos de lograr que cada concepto en nuestra aplicación sea expresado sólo
  una vez en el código.
</script></section><section data-markdown><script type="text/template">## Herencia
* Permite crear clases que son un refinamiento o especialización de otra clase.
* A esta clase se la llama *subclase* de la original.
* A la clase original se la llama *superclase* de la subclase.
* También se utilizan los términos: clase padre y clase hija.
* El mecanismo de herencia es simple:
  * Se heredan las capacidades del padre.
  * Los métodos de instancia y clase del padre estarán disponibles en los
    hijos.
</script></section><section data-markdown><script type="text/template">
## Ejemplo de herencia

<div class="container">
<div class="col">

```ruby
class Parent
  def say_hello
    puts "Hello from #{self}"
  end
end
```
</div>
<div class="col">

```ruby


p = Parent.new
p.say_hello


```
</div>
</div>
<div class="container">
<div class="col">

```ruby
class Child < Parent
end
```
</div>
<div class="col">

```ruby
c = Child.new
c.say_hello
```
</div>
</div>
</script></section><section data-markdown><script type="text/template">## Conociendo la herencia

El método `superclass` devuelve la clase padre

```ruby
puts "The superclass of Child is #{Child.superclass}"
puts "The superclass of Parent is #{Parent.superclass}"
puts "The superclass of Object is #{Object.superclass}"
```

>* Si no se define superclase, Ruby asume `Object`
>  * `to_s` está definido aquí
>* `BasicObject` es utilizado en metaprogramación. 
>  * Su padre es `nil`
>  * Es la raíz: todas las clases lo tendran como ancestro 
</script></section><section data-markdown><script type="text/template">## Ejemplo

<div class="small">

* `GServer` es un servidor TCP/IP genérico.
* Agregaremos funcionalidad básica a nuestro servicio subclaseando GServer.
  * El servicio mostrará las últimas lineas del archivo de logs del sistema:
    `/var/log/syslog`
* GServer manipula todo lo relacionado a sockets TCP.
  * Sólo indicaremos el puerto en la inicialización.
  * Cuando un cliente se conecte, el objeto GServer invocará al método `serve`.
  * GServer no hace nada en el método que implementa `serve`.
</div>
</script></section><section data-markdown><script type="text/template">## LogServer

```ruby
require 'gserver'
class LogServer < GServer

  def initialize
    super(12345)
  end

  def serve(client)
    log "Connected from #{remote_ip[2]}:#{remote_ip[1]}"
    client.puts get_end_of_log_file
  end

  private
    def get_end_of_log_file
      File.open("/var/log/syslog") do |log|
        # back up 1000 characters from end
        log.seek(-1000, IO::SEEK_END)
        # ignore partial line
        log.gets
        # and return rest
        log.read
      end
    end
end

server = LogServer.new
server.start.join
```

> GServer debe instalarse como una librería externa. [Ver
> ejemplo](https://github.com/ttps-ruby/teoria/tree/master/ejemplos/gserver)</script></section><section data-markdown><script type="text/template">## ¿Cómo hemos usado la herencia?

* `LogServer` hereda de `GServer`.
* Esto indica que: 
  * LogServer es un GServer, compartiendo toda su funcionalidad.
  * LogServer es una especialización.</script></section><section data-markdown><script type="text/template">## ¿Cómo usamos la herencia?

<div class="container small">
<div class="col">

### `initialize`

* Se fuerza el puerto a 12345.
* El puerto es un parámetro del constructor de GServer.
* Para invocar el método constructor del padre, utilizamos `super`.
</div>
<div class="col">

### `serve`
* El padre asume que será subclaseado invocando un método que será
  implementado por sus hijos.
* Esto permite a la clase padre implementar lo más pesado del procesamiento y
  delegar a los hijos mediante callbacks funcionalidad extra.
</div>
</div>

> * Veremos más adelante que esta práctica ***muy común en OO*** no la convierte en ***un buen diseño***
> * En su lugar veremos ***mixins***
> * Pero para explicar mixins, antes tenemos que explicar ***módulos***
</script></section><section data-markdown><script type="text/template">## Modulos
* Los módulos son una forma de agrupar métodos, clases y constantes. 
* Proveen dos beneficios:
  * Proveen **namespaces** y previenen el solapamiento de nombres.
  * Son la clave de los **mixins**.
</script></section><section data-markdown><script type="text/template">## Namespaces
* A medida que los programas crecen, surge código reusable.
* Es así como aparecen las librerías.
* Deseamos agrupar en archivos diferentes estas rutinas de forma tal
  de poder reusarlas en programas distintos.
* Generalmente estas rutinas pertenecerán a una clase, o grupos de clases
  interrelacionadas, que podríamos disponer en un único archivo.
  * Sin embargo, a veces queremos agrupar cosas que no necesariamente forman una
    clase.
</script></section><section data-markdown><script type="text/template">## Namespaces
* Como una primer idea, podríamos pensar en disponer todos los archivos que
  componen nuestra librería y luego cargar el archivo en nuestro programa cuando
  lo necesite.
* Esta idea tiene un problema si definimos funciones con nombres que son iguales 
  a los de otra librería.
</script></section><section data-markdown><script type="text/template">
## Ejemplo

<div class="container">
<div class="col">

```ruby 
module Trig
  PI = 3.141592654


  def self.sin(x)
  # ..
  end

  def self.cos(x)
  # ..
  end
end
```
</div>
<div class="col">

```ruby
module Moral
  VERY_BAD = 0
  BAD = 1

  def self.sin(badness)
  # ...
  end

end




```
</div>
</div>
</script></section><section data-markdown><script type="text/template">## ¿Como se usa?

```ruby
y = Trig.sin(Trig::PI/4)
wrongdoing = Moral.sin(Moral::VERY_BAD)
```

> * Así como en los métodos de clase, se invocan los métodos de un módulo
>   precediéndolos con el nombre del módulo y un punto.
> * Las constantes se referencian con el nombre del módulo y doble dos puntos (::).
</script></section><section data-markdown><script type="text/template">## Mixins
* En el ejemplo reciente, definimos métodos del módulo que prefijábamos con el
	nombre del módulo: `self.cos`.
* La primer asociación es que los métodos de un módulo son como métodos de
  clase.
* La siguiente pregunta sería: *Si los métodos del módulo son como métodos de
	clase, qué serían los métodos de instancia de un módulo?*.</script></section><section data-markdown><script type="text/template">## Mixins
* Un módulo **no puede tener instancias** porque no es una clase.
* Podremos **incluir** un módulo a una definición de clase.
* Cuando esto sucede, los métodos de instancia definidos en el módulo son
  incluidos como métodos de instancia de la clase. Se **mezclan** (mixed in).
* En efecto, los módulos mixins se comportan como superclases.
</script></section><section data-markdown><script type="text/template">## Ejemplo
```ruby

module Debug
  def who_am_i?
    "#{self.class.name}(\##{self.object_id}):#{self.to_s}"
  end
end

class Phonograph
  include Debug
  def initialize(n); @n=n; end
  def to_s; @n; end
end

class EightTrack
  include Debug
  def initialize(n); @n=n; end
  def to_s; @n; end
end

ph = Phonograph.new("West End Blues")
et = EightTrack.new("Surrealistic Pillow")
ph.who_am_i?
et.who_am_i?
```
</script></section><section data-markdown><script type="text/template">## El uso de include
* El `include` en Ruby agrega una referencia al módulo que agregará nuevos
  métodos a nuestra clase.
* Si varias clases incluyen el mismo módulo, todas tendran referencias al mismo.
* Si modificamos el módulo durante la ejecución del programa, todas las clases
  que incluían el módulo tomarán los cambios automáticamente.
</script></section><section data-markdown><script type="text/template">## El potencial
* El potencial real de los mixins se obtiene cuando el código de un mixin
  interactúa con código de una clase que lo utiliza.
* Analizamos el caso de un mixin que es parte de la librería estándar de Ruby,
  `Comparable`:
  * Agrega los operadores de comparación: `<`, `<=`, `==`, `>=`, `>`.
  * Agrega el método `between?`.
  * Asume que la clase que utilice este mixin, implementará el método `<=>`.
</script></section><section data-markdown><script type="text/template">## Probamos con `Person`

<div class="container">
<div class="col">

```ruby
class Person
  include Comparable
  attr_reader :name
  def initialize(name)
    @name = name
  end
  def to_s
    "#{@name}"
  end
  def <=>(other)
    self.name <=> other.name
  end
end
```
</div>
<div class="col">

```ruby
p1 = Person.new("Matz")
p2 = Person.new("Guido")
p3 = Person.new("Larry")
[p1, p2, p3].sort
```
</div>
</div>
</script></section><section data-markdown><script type="text/template">## Iteradores y `Enumerable`
* Si queremos que nuestra clase entienda los iteradores `each`, `include?`,
  `find_all?`, `map`, `inject`, `count`, etc.
  * Incluimos el módulo `Enumerable`.
  * Implementamos el iterador `each`.
* Si además los elementos de nuestra colección implementan `<=>` entonces
    dispondremos de: 
  * `min`
  * `max`
  * `sort`</script></section><section data-markdown><script type="text/template">## Composición de módulos

Creamos nuestra clase Enumerable

<div class="container">
<div class="col">

```ruby
class VowelFinder
  include Enumerable
  def initialize(string)
    @string = string
  end
  def each
    @string.scan(/[aeiou]/i) do |vowel|
      yield vowel
    end
  end
end
vf = VowelFinder.new "El murcielago tiene todas"
vf.inject(:+)
```
</div>
<div class="col">

> Ahora nuestra clase funciona igual que otras colecciones:

```ruby
[ 1, 2, 3, 4, 5 ].inject(:+)
( 'a'..'m').inject(:+)
```
</div>
</div>
</script></section><section data-markdown><script type="text/template">## Creamos el módulo Summable

```ruby
module Summable
  def sum
    inject(:+)
  end
end
```

Lo aplicamos a las clases del ejemplo

```ruby
class Array; include Summable; end
class Range; include Summable; end
class VowelFinder; include Summable; end

[ 1, 2, 3, 4, 5 ].sum
('a'..'m').sum
vf.sum
```
</script></section><section data-markdown><script type="text/template">## Variables en mixins

<div class="small container">
<div class="col">

```ruby 
module Observable

  def observers
    @observer_list ||= []
  end

  def add_observer(obj)
    observers << obj
  end

  def notify_observers
    observers.each {|o| o.update }
  end
end
```
</div>
<div class="col">

> * En ruby las variables de instancia se crean cuando se nombran por
>   primera vez.
> * Esto significa que un Mixin podrá crear variables de instancia si las nombra
>   por primera vez en la clase.

</div>
</div>
</script></section><section data-markdown><script type="text/template">## Variables en mixins
* Sin embargo, este uso es **riesgoso**.
* Los nombres de las variables pueden colisionar con otro nombre de la clase u
  otros módulos.
* Un programa que caiga en este escenario dará resultados erróneos y
  difíciles de rastrear.
</script></section><section data-markdown><script type="text/template">### Solución
* La mayoría de las veces, los modulos Mixins no usan variables de instancia,
  sino accessors.
* En caso de necesitarlo, utilizar nombres que se prefijen con el nombre del
  módulo por ejemplo.
</script></section><section data-markdown><script type="text/template">## Resolución de nombres

*¿Cómo se resuelve el nombre de un método que es el mismo en la clase, que 
es implementado en la superclase y además definido en uno o varios módulos 
incluidos?*
</script></section><section data-markdown><script type="text/template">## Resolución de nombres

* Primero se busca si la clase del objeto lo implementa.
* Luego en los mixins incluidos por la clase. *Si tiene varios módulos, el
  último será el considerado*.
* Luego en la superclase.
</script></section><section data-markdown><script type="text/template"><div class="container">
<div class="col">

### Caso 1

```ruby
module MyModule
  def test
    "Module"
  end
end

class Parent
  def test
    "Parent"
  end
end

class Child < Parent
  include MyModule
  def test
    "Child"
  end
end

t = Child.new
p t.test
```

#### Child<!-- .element: class="fragment" -->
</div>
<div class="col">

### Caso 2

```ruby
module MyModule
  def test
    "Module"
  end
end

class Parent
  def test
    "Parent"
  end
end

class Child < Parent
  include MyModule
end

t = Child.new
p t.test
```

#### Module<!-- .element: class="fragment" -->
</div>
<div class="col">

### Caso 3

```ruby
module MyModule
  def test1
    "Module"
  end
end

class Parent
  def test
    "Parent"
  end
end

class Child < Parent
  include MyModule
end

t = Child.new
p t.test
```

#### Parent<!-- .element: class="fragment" -->
</div>
</div>
</script></section><section data-markdown><script type="text/template">## Invocación de métodos

Si analizamos la salida de `#ancestors` veremos la cadena Clases por la
que se buscará por un método apropiado. Veamos el siguiente ejemplo:

<div class="container">
<div class="col">

```ruby
module Logging
  def log(level, message)
      puts "#{level}: #{message}"
  end
end

class Service
  include Logging
end

Service.ancestors
```

</div>
<div class="col">

> La salida es:
> 
> `[Service, Logging, Object, Kernel, BasicObject]`
> 
> Notar que Logging se interpone entre Object y Service

</div>
</div>
</script></section><section data-markdown><script type="text/template">## Ancestros y módulos

Si agregamos otro Modulo a la clase anterior:

```ruby
Service.include Comparable
```

Podemos verificar que el último módulo incluido aparece detrás de la clase
`Service`, explicando así las precedencias explicadas como casos anteriormente.

```ruby
[Service, Comparable, Logging, Object, Kernel, BasicObject]
```
</script></section><section data-markdown><script type="text/template">## extend

Utilizar `#extend` en una clase importará los métodos del módulo como métodos de
clase.

En vez de actualizar la lista de ancestros, `#extend` modificará el singleton de
la clase extendida, agregando métodos de clase.

En general, se utilizará `#include` en una clase para extender el comportamiento
con métodos de instancia, pero a su vez podría necesitarse usar `#extend` para
extender los métodos de clase. Entonces se necesitarían **dos modulos diferentes
para cada caso.**
</script></section><section data-markdown><script type="text/template">## extend

La siguiente estrategia permite crear dos módulos para extender clases y objetos
en un mismo código:

```ruby
module Logging
  module ClassMethods
    def logging_enabled?
      true
    end
  end

  def self.included(base)
    base.extend(ClassMethods)
  end

  def log(level, message)
    puts "#{level}: #{message}"
  end
end
```</script></section><section data-markdown><script type="text/template">## extend vía include

Usando el ejemplo anterior, al realizar:

```ruby

String.include Logging

String.logging_enabled?

'Test'.log 'ERROR', 'test message'

```</script></section><section data-markdown><script type="text/template">
## Herencia, Mixins y Diseño
Herencia y Mixins ambos permiten escribir código en un único lugar.

**¿Cuándo usar cada uno?**</script></section><section data-markdown><script type="text/template">## Herencia, Mixins y Diseño

* El uso de herencia debe aplicarse cuando se cumple la propiedade **es un**.
* La herencia puede asociarse con la creación de clases, que sería como 
agregar nuevos tipos al lenguaje.
* Al usar herencia **deberíamos en todo momento poder reemplazar un objeto de
  la superclase por un objeto de la subclase**. *Los hijos deben
  hacer honor a los contratos asumidos por el padre*.
</script></section><section data-markdown><script type="text/template">## Herencia, Mixins y Diseño

* Muchas veces se utiliza **mal** en situaciones que representan 
  una relación de *posee un* o *utiliza un*.
* El mundo se crea a partir de **composiciones** más que de restricciones de
  herencia estrictas.

> Una persona no es un DatabaseWrapper. Una Persona **usa** un DatabaseWrapper
> para persistirla.</script></section><section data-markdown><script type="text/template">## Herencia, Mixins y Diseño

* La herencia representa un gran acomplamiento entre dos componentes.
  * Cambiar la herencia sería algo complejo en cualquier programa mediano.
* **Debemos utilizar composición cada vez que encontramos una relación:** A
  *usa* B o A *tiene un* B

</script></section></section><section ><section data-markdown><script type="text/template">
# Excepciones
</script></section><section data-markdown><script type="text/template">## Introducción

* Las excepciones permiten empaquetar en un objeto información sobre un error.
* El objeto `Exception` se propagará hacia arriba en la pila de ejecución hasta
  que el sistema detecte código que sepa manejar dicha excepción.
</script></section><section data-markdown><script type="text/template">## La clase Exception

* Ruby define una jerarquía de excepciones que son subclase de `Exception`.
* Al lanzar una excepción, es posible hacerlo con cualquiera de las subclases de
`Exception` o con una clase propia.
* Toda excepción tiene asociado un mensaje y una traza de ejecución.
  * Si definimos excepciones propias, podemos agregar información específica
</script></section><section data-markdown><script type="text/template">## Manejo de excepciones

Analizamos el siguiente código

```ruby
require 'open-uri'

web_page = open("https://www.ruby-lang.org/en/documentation/")
output = File.open("ruby.html", "w")
while line = web_page.gets
  output.puts line
end
output.close
```

* ¿Qué sucede si ocurre un error en la mitad de la transferencia?
* No queremos guardar una página por la mitad en el archivo de salida
</script></section><section data-markdown><script type="text/template">## Manejo de excepciones

Agregamos el manejador de excepción

```ruby
require 'open-uri'

page = "unlp"
file_name = "#{page}.html"
web_page = open("https://www.ruby-lang.org/en/#{page}")
output = File.open(file_name, "w")
begin
  while line = web_page.gets
    output.puts line
  end
  output.close
rescue Exception
  STDERR.puts "Failed to download #{page}: #{$!}"
  output.close
  File.delete(file_name)
  raise
end
```
</script></section><section data-markdown><script type="text/template">## Manejo de excepciones

* Cuando sucede una excepción se ubica una referencia al objeto con la excepción
  asociada en la variable global **`$!`**.
* Luego de cerrar y eliminar el archivo, se invoca a `raise` sin parámetros, que
  relanza la excepción en **`$!`**.

</script></section><section data-markdown><script type="text/template">
## Jerarquía de Exception

<div class="container">

<div class="col">

```ruby
Exception
  StandardError
    ArgumentError
    FiberError (1.9)
    IndexError
      KeyError (1.9)
      StopIteration (1.9)
    IOError
      EOFError
    LocalJumpError
    NameError
      NoMethodError
```
</div>
<div class="col">

```ruby
Exception
  StandardError
    RangeError
      FloatDomainError
    RegexpError
    RuntimeError
    SystemCallError
      (Errno::xxx)
    ThreadError
    TypeError
    ZeroDivisionError
  fatal
```

</div>
<div class="col">

```ruby
Exception
  NoMemoryError
  ScriptError
    LoadError
    NotImplementedError
    SyntaxError
  SecurityError 
  SignalException
    Interrupt
  SystemExit
  SystemStackError


```
</div>
</div>
</script></section><section data-markdown><script type="text/template">## Múltiples rescue

<div class="small">

* Es posible utilizar varios `rescue` para un bloque.
* Cada `rescue` puede indicar varias excepciones a catchear.
* Al final de cada `rescue`, podemos indicar el nombre de la variable que
  usaremos para mapear la exepción (en vez de usar `$!`)


```ruby
def my_eval(string)
  begin
    eval string
  rescue SyntaxError, NameError => boom
    print "String doesn't compile: " + boom.message
  rescue StandardError => bang
    print "Error running script: " + bang.message
  end
end
my_eval 'Float 2,2'
my_eval 'undefined_method'
```
</div></script></section><section data-markdown><script type="text/template">## Cómo funciona rescue
* La decisión de qué `rescue` utilizar, es similar al caso de un `case`.
* Cada `rescue` compara la excepción lanzada con cada uno de los parámetros
  nombrados:
  * La comparación es: `parámetro == $!`
  * Esto significaría que si el tipo de la excepción lanzada coincide con el del
    parámetro.</script></section><section data-markdown><script type="text/template">## Cómo funciona rescue
* Si se omiten parámetros, se compara con `StandardError`.
* Si no machea con ningún parámetro, sale del bloque `begin/end` buscando en el
  método que invocó un manejador para la misma, y así siguiendo hacia arriba en
  la pila.
* Casi siempre usaremos nombre de clases como parámetros a `rescue`, pero
  podemos usar expresiones que retornen una subclase de `Exception`.
</script></section><section data-markdown><script type="text/template">## Asegurando la ejecución
* Varias veces necesitamos ejecutar determinado código al finalizar un método de
  forma segura, es decir independientemente de si se produce un error en la
  mitad:
  * Por ejemplo, tenemos un archivo abierto, que necesitamos cerrar antes
    de finalizar el bloque.
* El código bajo `ensure` se ejecutará siempre, haya sido una ejecución exitosa
  o con algún problema.
</script></section><section data-markdown><script type="text/template">## Un ejemplo ensure

```ruby
f = File.open("testfile")
begin
  # .. process
rescue
  # .. handle error
ensure
  f.close
end
```
</script></section><section data-markdown><script type="text/template">## El else de rescue

* El `else` aplica cuando ninguno de los `rescue` manejan la excepción.
* Tener cuidado porque `ensure` ejecutará siempre, incluso cuando no se produce
  un error.

```ruby
f = File.open("testfile")
begin
  # .. process
rescue
  # .. handle error
else
  puts "Congratulations-- no errors!"
ensure
  f.close
end
```
</script></section><section data-markdown><script type="text/template">## Volver a empezar...

* A veces podemos corregir una causa de excepción.
* Para estos casos, podemos usar `retry` para volver a ejecutar el bloque
  `begin/end`.
* Es muy factible caer en loops infinitos.
</script></section><section data-markdown><script type="text/template">## Ejemplo retry

```ruby
@esmtp = true
begin
# First try an extended login. If it fails 
# because the server doesn't support it, 
# fall back to a normal login
if @esmtp then
  @command.ehlo(helodom)
else
  @command.helo(helodom)
end
rescue ProtocolError
  if @esmtp then
    @esmtp = false
    retry
  else
    raise
  end
end
```
</script></section><section data-markdown><script type="text/template">## Lanzando excepciones

Podemos lanzar excepciones usando el método `Kernel.raise`

```ruby
raise
raise "bad mp3 encoding"
raise InterfaceException, "Keyboard failure", caller
```

<div class="small">

* La primer forma **relanza una excepción** si la hubiere, o **`RuntimeError`** si no.
  Usualemnte dentro de `rescue` para el primer caso.
* El segundo ejemplo, lanza **`RuntimeError`** con el mensaje indicado.
* El tercer ejemplo, utiliza el primer parámetro para crear un excepción con el
  segundo parámetro usado como mensaje y la pila de ejecución en el tercer
  parámetro.  **`Kernel.caller`** genera la traza de ejecución.

</div></script></section><section data-markdown><script type="text/template">## Ejemplo de raise

```ruby
raise
raise "Missing name" if name.nil?
if i >= names.size
  raise IndexError, "#{i} >= size (#{names.size})"
end
raise ArgumentError, "Name too big", caller
```

*Generalmente no se incluye la traza en librerías*
</script></section><section data-markdown><script type="text/template">## catch y throw

* Veremos un ejemplo que aclarará el concepto
  * El siguiente código leerá palabras que irá agregando en un arreglo que al
    finalizar imprimirá en orden inverso. Sin embargo, si alguna línea es
    incorrecta deberá salir sin hacer nada.
  * El secreto es `throw(symbol, variable)`.

> En el siguiente ejemplo es importante que el último **puts** retorna `nil`
</script></section><section data-markdown><script type="text/template">## Ejemplo de catch y throw

```ruby
def only_words(filename)
  word_list = File.open(filename)
  word_in_error = catch(:done) do
    result = []
    while line = word_list.gets
      word = line.chomp
      throw(:done, word) unless word =~ /^\w+$/
      result << word
    end
    puts result.reverse
  end
  if word_in_error
    puts "Failed: '#{word_in_error}' found. Not a word"
  end
end
```




</script></section></section></div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"transition":"slide"}, queryOptions);
    </script>

    <script src="./_assets/src/js/clipboard.min.js"></script>
    <script src="./_assets/node_modules/reveal.js-copycode/plugin/copycode/copycode.js"></script>
    <script src="./_assets/src/js/custom.js"></script>

    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
