<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Tecnologías de Producción de Software</title>
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/white.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/vs2015.css" />
    <link rel="stylesheet" href="./_assets/node_modules/reveal.js-copycode/plugin/copycode/copycode.css" />
    <link rel="stylesheet" href="./_assets/src/css/styles.css" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section  data-markdown><script type="text/template">
### Tecnologías de Producción de Software

<img class="main" height="250px" src="static/logo.svg" />

# Ruby

<div class="container">
  <div class="col">
    <a href="https://www.info.unlp.edu.ar">
    <img class="main" height="100px" src="static/info-unlp.png" />
    </a>
  </div>
  <div class="col">
    <a href="https://www.unlp.edu.ar">
    <img class="main" height="100px" src="static/unlp.svg" />
    </a>
  </div>
</div></script></section><section ><section data-markdown><script type="text/template">
# Presentación</script></section><section data-markdown><script type="text/template">## La cátedra 

| Profesor | Contacto |
| ---- | --- |
| Lic. Christian A. Rodríguez | [![car@info.unlp.edu.ar](static/mail.svg)](mailto:car@info.unlp.edu.ar "car@info.unlp.edu.ar")<!-- .element: class="social"--> [![twitter](static/twitter.svg)](https://twitter.com/car_unlp "twitter")<!-- .element: class="social"--> [![github](static/github.svg)](https://github.com/chrodriguez "github")<!-- .element: class="social"--> | 

| Jefe de Trabajos Prácticos | Contacto |
| ---- | --- |
| Lic. Nahuel Cuesta Luengo | [![ncuesta@cespi.unlp.edu.ar](static/mail.svg)](mailto:ncuesta@cespi.unlp.edu.ar "ncuesta@cespi.unlp.edu.ar")<!-- .element: class="social"--> [![twitter](static/twitter.svg)](https://twitter.com/ncuestal "twitter")<!-- .element: class="social"--> [![github](static/github.svg)](https://github.com/ncuesta "github")<!-- .element: class="social"--> |

| Ayudantes | Contacto |
| ---- | --- |
|Lic. Patricio Mac Adden | [![patriciomacadden@gmail.com](static/mail.svg)](mailto:patriciomacadden@gmail.com "patriciomacadden@gmail.com")<!-- .element: class="social"--> [![twitter](static/twitter.svg)](https://twitter.com/maxawen "twitter")<!-- .element: class="social"--> [![github](static/github.svg)](https://github.com/patriciomacadden "github")<!-- .element: class="social"--> | 
| Damián Candia | [![dcandia@cespi.unlp.edu.ar](static/mail.svg)](mailto:dcandia@cespi.unlp.edu.ar "dcandia@cespi.unlp.edu.ar")<!-- .element: class="social"--> |
</script></section><section data-markdown><script type="text/template">## Horarios de cursada

| Día | Hora | Aula |
| --- | --- | --- |
| Martes | 11 a 13 | 10-A |
| Jueves | 11 a 13 | 10-A |
</script></section><section data-markdown><script type="text/template"><!-- .slide: data-auto-animate -->
## Programa

Dividimos el programa en cuatro secciones principales:

* **Introducción**
* **El lenguaje**
* **Gemas**
* **Rails**</script></section><section data-markdown><script type="text/template"><!-- .slide: data-auto-animate -->
## Programa

* **Introducción**
  * Se realiza un recorrido rápido acerca de la historia del
  lenguaje.
  * Con ejemplos, mostramos el potencial del lenguaje.
  * Presentamos las diferentes implementaciones de ruby y su instalación.
* **El lenguaje**
* **Gemas**
* **Rails**</script></section><section data-markdown><script type="text/template"><!-- .slide: data-auto-animate -->
## Programa

* **Introducción**
* **El lenguaje**: en esta sección profundizamos sobre el lenguaje:
  * Objetos, arreglos, hashes, símbolos, tipos estándar
  * Estructuras de control
  * Bloques e iteradores
  * E/S estandar
  * Clases de objetos, métodos y variables
  * Módulos y mixins
* **Gemas**
* **Rails**</script></section><section data-markdown><script type="text/template"><!-- .slide: data-auto-animate -->
## Programa

* **Introducción**
* **El lenguaje**
* **Gemas:** a las librerias que extienden Ruby se las llaman Gemas. En esta sección
abordaremos:
  * Manejo de dependencias
  * Bundler
* **Rails**
</script></section><section data-markdown><script type="text/template"><!-- .slide: data-auto-animate -->
## Programa

* **Introducción**
* **El lenguaje**
* **Gemas**
* **Rails:** el framework más utilizado por los desarrolladores Ruby. En esta sección
aprenderemos a trabajar con este framework:
  * Conceptos básicos
  * Ruteo
  * ActiveRecord
  * Unit Testing
  * MVC</script></section><section data-markdown><script type="text/template">## Modalidad de cursada

* **Aprobación de la cursada:** 
  * Una **evaluación o entrega** (estamos definiendo el mejor criterio
    de evaluación) para cada tema. En caso de no
    aprobar algún tema, se podrá reiterar la evaluación de aquellos temas no
    aprobados.
  * **Trabajo práctico final integrador**
* La nota final de la materia será un **seis aprobando la cursada**. Será
  posible mejorar la nota con una extensión del trabajo práctico integrador o
  propuesta de trabajo conjunta con el profesor.
</script></section><section data-markdown><script type="text/template">## Bibliografía / Recursos
A medida que se presenten los temas se indicarán las fuentes apropiadas



<small>

Todo el material se encuentra bajo licencia **Creative Commons**

<span xmlns:dct="https://purl.org/dc/terms/" property="dct:title">TTPS - Opcion Ruby</span> por 
<span xmlns:cc="https://creativecommons.org/ns#" property="cc:attributionName">Christian A. Rodriguez</span> se encuentra bajo
una <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/3.0/deed.es">Licencia Creative Commons Atribución-NoComercial-CompartirIgual 3.0 Unported</a>.
<br />
<a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/3.0/deed.es">
<img alt="Licencia Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a>

<div>Icons made by <a href="https://www.flaticon.com/authors/pixel-perfect" title="Pixel perfect">Pixel perfect</a> from <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com</a></div>

</small>


</script></section></section><section  data-markdown><script type="text/template">
# Introducción

<div class="main-list">

* historia
* el lenguaje
* interpretes
</div>
</script></section><section ><section data-markdown><script type="text/template">
# Historia

<div class="main-list">

* introducción
</div></script></section><section data-markdown><script type="text/template">## [Yukihiro Matsumoto](https://en.wikipedia.org/wiki/Yukihiro_Matsumoto)


<div class="container small">
  <div class="col">

  ![Yukihiro Matsumoto](static/yukihiro-matsumoto.jpg)<!-- .element: class="shade" -->

  </div>
  <div class="col">

  ![Ruby](static/logo.svg)<!-- .element: height="80px" -->
  * En japonés: 松本行弘 (まつもとゆきひろ)
  * Matz más simple
  * Empezó el desarrollo de Ruby en 1993
  * En 1995 lanzó la primera versión
  * Aún lidera el desarrollo de Ruby
  </div>
</div>

<small>

## Su célebre frase

  Ruby is designed to make programmers **HAPPY**

</small>
</script></section><section data-markdown><script type="text/template"><!-- .slide: data-auto-animate -->
## ¿Cómo surge Ruby?

* Fusión de lenguajes
  * Smalltalk
  * Perl
  * LISP
* Hasta el 2001 conocido sólo en Japón
  * El libro [Programming Ruby](https://pragprog.com/book/ruby/programming-ruby) fue el 
    impulsor del lenguaje fuera de Japón
  * También conocido como PickAxe
  * La primera versión puede [leerse en línea](https://ruby-doc.org/docs/ProgrammingRuby/)
</script></section><section data-markdown><script type="text/template"><!-- .slide: data-auto-animate -->
## ¿Cómo surge Ruby?

![pickaxe](static/pickaxe.jpg)<!-- .element: class="shade" height="500px" -->
</script></section><section data-markdown><script type="text/template">## [David Heinemeier Hansson](https://en.wikipedia.org/wiki/David_Heinemeier_Hansson)

<div class="container small">
  <div class="col">

![DHH](static/dhh.jpg)<!-- .element: class="shade"-->

  </div>
  <div class="col">

![Rails](static/rails.svg)<!-- .element: height="80px" -->

  * Creador de [Rails](https://rubyonrails.org/): _framework open source para desarrollo de aplicaciones web_
  * Su primer versión liberada (1.0) fue en 2005

  </div>
</div>



</script></section></section><section ><section data-markdown><script type="text/template">
# El lenguaje

<div class="main-list">

* introducción
</div>
</script></section><section data-markdown><script type="text/template"># El lenguaje

* Dinámico
* Sintaxis concisa y expresiva 
* Orientado a objetos
* Capacidades de metaprogramación
* Características funcionales
</script></section><section data-markdown><script type="text/template">## Sintaxis y convenciones

Nombres válidos y convenciones:

```ruby
  NombreDeClaseOModulo
  CONSTANTE
  @nombre_de_atributo
  @@atributo_de_clase
  $variable_global
  nombre_de_metodo
  metodo_peligroso!
  metodo_que_pregunta?
```
</script></section><section data-markdown><script type="text/template">## Objetos

Todos los valores son **objetos**

```ruby
"Aprendiendo ruby".length
"Aprendiendo ruby".each_char.sort.join
1 + 2
1.send :+, 2
```
## Arreglos

```ruby
["Go", "Ruby", "Java", "Python", "PHP", "Javascript"].sort
([1,2,3] + [4,5,6]).last
```
</script></section><section data-markdown><script type="text/template">

## Números

```ruby
-100.abs
1_123_456 * 1_000_000
1.5 * 3
0b1000_1000   # Binario     =>  136
010           # Octal       =>    8
0x10          # Hexadecimal =>   16
```

<div class="container">
  <div class="col">

### nil

```ruby
a = Array.new
a[10].nil?
nil.nil?
```

  </div>
  <div class="col">

### object id

```ruby
1.object_id
nil.object_id
```
  </div>
</div></script></section><section data-markdown><script type="text/template">
## Strings

<div class="container">
  <div class="col">

### Literales

```ruby
'sin interpolar'
"Interpolando: #{'Ja'*3}!"

# Notación alternativa
%q/Hola/
%q!Chau!
%Q{Interpolando: #{3+3}}
```
  </div>
  <div class="col">

### Here document

```ruby
un_string = <<-EOS
  Este es un texto
  de mas de una linea
  que termina aqui.
  Se puede observar que
  espacios antes de cada
  linea.
EOS

un_string.upcase
```
  </div>
</div>
</script></section><section data-markdown><script type="text/template">## Símbolos

* Son como variables prefijados con **:** (dos puntos)
  * Ejemplos: `:action`, `:line_items`, `:+`
* No es necesario declararlos 
* Se garantiza que son únicos
  * No es necesario asignarles ningún valor

```ruby

:uno.object_id  # siempre devolverá lo mismo
"uno".object_id # siempre devolverá diferente

```</script></section><section data-markdown><script type="text/template">## Colecciones

<div class="container small">
  <div class="col">

### Arreglos

```ruby

['Hola', 'Chau']

# sin interpolar
%w(Hola Chau #{2+2})

# interpolando
%W(Hola Chau #{2+2})

[1,2,3,4]
```

  </div>
  <div class="col">


### Hashes

```ruby
# Versión 1.8
{
  :nombre   => 'Christian',
  :apellido   => 'Rodriguez'
}
# Versión > 1.8
{
  nombre:   'Christian',
  apellido:   'Rodriguez'
}
```

  </div>
</div>
</script></section><section data-markdown><script type="text/template">## Expresiones regulares

```ruby
/^[a-zA-Z]+$/
"Do you like cats?" =~ /like/
"192.168.0.10" =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/
```


> Explicación en [Pickaxe](https://ruby-doc.com/docs/ProgrammingRuby/html/intro.html#S5).
> Con [Rubular](https://rubular.com/) es posible probarlas.</script></section><section data-markdown><script type="text/template"><div class="container small">
  <div class="col">

## Rangos

```ruby

0..1
0..10
"a".."z"
"a"..."z"

# Pueden convertirse en arreglos
("a"..."z").to_a

# Rangos como intervalos
(1..10) === 5     # => true
(1..10) === 15    # => false
(1..10) === 3.1   # => true

```

  </div>
  <div class="col">

## Expresiones

```
a = 3.14 # => 3.14

# Veamos el case
estado = nil
face =  case estado
        when "Feliz"  then ":)"
        when "Triste" then ":("
        else               ":|"
end

```


> En Ruby toda expresión retorna un valor 

  </div>
</div>
</script></section><section data-markdown><script type="text/template">
<div class="container small">
  <div class="col">

## Lambdas

```ruby
uno = lambda { |n| n * 2 }
dos = ->(n, m){ n * 2 + m }
tres  = ->(n, m=0){ n * 2 + m}

# Entonces

uno.call 2      # => 4
dos.call 2,3    # => 7
tres.call 2     # => 4
```
  </div>
  <div class="col">

## Bloques


```ruby
3.times do |i|
  puts i
end

3.times { |i| puts i }
```

> Rara vez usaremos un for / while

  </div>
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: data-auto-animate -->
## Ejemplos de bloques y colecciones


<pre data-id="code-animation"><code class="ruby hljs" data-trim data-line-numbers>
# Selección de números pares
(1..10).select { |n| n.even? }

# Procesar cada elemento de una colección
(1..10).map { |n| n*2 }

# Calcular con los elementos de la colección:
(1..100).reduce { |sum,n| sum + n }
</code></pre>


</script></section><section data-markdown><script type="text/template"><!-- .slide: data-auto-animate -->
## Ejemplos de bloques y colecciones

<pre data-id="code-animation"><code class="ruby hljs" data-trim data-line-numbers="3,4,8,9,13,14">
# Selección de números pares
(1..10).select { |n| n.even? }
# o lo que es igual:
(1..10).select(& :even?)

# Procesar cada elemento de una colección
(1..10).map { |n| n*2 }
# o lo que es igual:
(1..10).collect { |n| n*2 }

# Calcular con los elementos de la colección:
(1..100).reduce { |sum,n| sum + n }
# o lo que es igual:
(1..100).reduce(:+)
</code></pre>
</script></section><section data-markdown><script type="text/template">## Bloques y archivos

```ruby

File.open('/etc/passwd').each do |line|
  puts line if line =~ /root/
end
```


</script></section></section><section ><section data-markdown><script type="text/template">
# Intérpretes

<div class="main-list">

* introducción
</div>
</script></section><section data-markdown><script type="text/template">
Ruby como lenguaje, tiene varias implementaciones. La implementación de
referencia es conocida como **MRI: _Matz’s Ruby Interpreter_** o **CRuby**
(porque está desarrollada en C), pero existen otras implementaciones.
</script></section><section data-markdown><script type="text/template">
## MRI

* **Homepage:** https://www.ruby-lang.org/
* Matz' Ruby Implementation
* También llamada CRuby
* Es la implementación de referencia del lenguaje
* Versiones
  * **1.8.x**
  * **1.9.x**
  * **2.x**
  * Ruby 3 will be 3 times faster <!-- .element: class="fragment" -->
</script></section><section data-markdown><script type="text/template">## JRuby


* **Homepage:** https://www.jruby.org/
* Ruby en la **JVM de Java**
* Es la alternativa más madura a MRI en términos de compatibilidad con MRI
* Ventajas:
  * Concurrencia real
  * Interoperabilidad con librerías Java

<img src="static/jruby.png" height="200" />
</script></section><section data-markdown><script type="text/template">## Rubinius

* **Homepage:** https://github.com/rubinius/rubinius
* Comenzó como un experimento que comenzó como una implementación de Ruby, pero
  en realidad apunta a extender las limitaciones de Ruby.
* Su diseño se enfoca en la concurrencia.
* La VM fue escrita en C++
</script></section><section data-markdown><script type="text/template">## TruffleRuby

* **Homepage:** https://github.com/oracle/truffleruby
* Es una implementación de alta performance de Ruby creada por Oracle.
* Permite correr código en paralelo y el startup de aplicaciones ruby es mucho
  menor.
* Basado en [GraalVM](http://graalvm.org/). 

<img src="static/truffleruby.png" height="200" /></script></section><section data-markdown><script type="text/template">## ¿Cómo trabajar con ruby?

* Mayormente la gestión del ambiente de trabajo con ruby se realiza con alguna
  de las siguientes herramientas:
  * [**RVM:** Ruby Version Manager](https://rvm.io/)
  * [**rbenv:** Ruby environment](https://github.com/rbenv/rbenv)
  * _Ruby instalado como paquete del propio sistema no es recomendado._

> El uso, instalación y manejo de los entornos serán abordados en el espacio de
> las prácticas




</script></section></section><section  data-markdown><script type="text/template">
# Ruby

<div class="main-list">

* objetos y atributos
* clases y variables
* colecciones
* bloques e iteradores
* módulos
* excepciones
* conceptos avanzados (ex slide-09)
</div>
</script></section><section ><section data-markdown><script type="text/template">
# Objetos y atributos

<div class="main-list">

* ruby

</div>
</script></section><section data-markdown><script type="text/template">## Aprendemos con un ejemplo

* Sistema que realiza control de stock de libros.
* Utilizando un lector de código de barra se lee de cada libro información que
  luego se descargará como CSV
* Ejemplo del CSV:

```csv
"Date","ISBN","Amount"
"2008-04-12","978-1-9343561-0-4",39.45
"2008-04-13","978-1-9343561-6-6",45.67
"2008-04-14","978-1-9343560-7-4",36.95
```
</script></section><section data-markdown><script type="text/template">## ¿Qué debe hacer el sistema?

* Leer varios archivos CSV y determinar cuántos ejemplares de cada
  título disponemos
* Determinar además el monto total en libros que tenemos
</script></section><section data-markdown><script type="text/template">## Creamos la clase BookInStock


```ruby
class BookInStock
end
```
> Recordamos que los nombres de las clases deben comenzar con mayúsculas, los
métodos con minúscula

<div class="fragment" >

### Lo probamos

```ruby
a_book = BookInStock.new
another_book = BookInStock.new
```
</div>
</script></section><section data-markdown><script type="text/template">## Observaciones

* Se crean dos objetos diferentes de la clase `BookInStock`. 
* Podríamos decir en esta primer instancia que son el mismo libro, o iguales porque **nada los
distingue**.
* Lo solucionamos obligando que la inicialización indique aquellos datos que distinga al
libro.
</script></section><section data-markdown><script type="text/template">
## Variables de instancia

```ruby
class BookInStock
  def initialize(isbn, price)
    @isbn = isbn
    @price = Float(price)
  end
end
```

* El método `initialize` es especial en Ruby 
* Cuando se invoca el método `new`, Ruby aloca memoria para alojar un objeto no
  inicializado y luego invoca al método `initialize` **pasándole cada parámetro
  que fue enviado a `new`**.
* Entonces `initialize` nos permite configurar el estado inicial de nuestros objetos.
</script></section><section data-markdown><script type="text/template">## En el método initialize

* Se utilizan variables de instancia: comienzan con **@**.
* Las variables `@isbn` e `isbn` son diferentes.
* Se realiza una pequeña validación implícita:
  * El método [`Float`](http://www.ruby-doc.org/core-2.0.0/Kernel.html#method-i-Float)
    toma un argumento y lo convierte a `float`, terminando el programa si falla
    la conversión</script></section><section data-markdown><script type="text/template">
## Usamos los nuevos objetos

```ruby
b1 = BookInStock.new("isbn1", 3)
p b1
b2 = BookInStock.new("isbn2", 3.14)
p b2
b3 = BookInStock.new("isbn3", "5.67")
p b3
```

> Usamos el método `p` porque imprime el estado interno de los objetos.
> Si se utilizara `puts` entonces se invocaría `to_s` e imprimiría:
> `#<nombre_de_clase:id_objeto_en_hex>`
</script></section><section data-markdown><script type="text/template">
## Implementamos to_s

```ruby
class BookInStock
  def to_s
    "ISBN: #{@isbn}, price: #{@price}"
  end
end
```

> Probar nuevamente `puts b3`</script></section><section data-markdown><script type="text/template">## Objetos y sus atributos

* Un objeto como el mostrado anteriormente no permite que nadie acceda a sus
  variables.
* Si bien es algo positivo encapsular, si no permitimos acceder a los datos que
  mantienen el estado del objeto, el mismo se vuelve inútil.
* A las *ventanas* de acceso a los objetos las denominaremos **atributos**.
* Modificaremos nuestra clase de `BookInStock` con el fin de agregar atributos
  para `isbn` y `price` así podemos contabilizarlos.
</script></section><section data-markdown><script type="text/template">## Getters

```ruby
class BookInStock
  def isbn
    @isbn 
  end

  def price
    @price
  end
end
```
</script></section><section data-markdown><script type="text/template">## Atributos de lectura

A los atributos anteriores se los denomina **accesor** porque mapean
directamente con las variables de instancia. Ruby provee un shortcut: **`attr_reader`**.

```ruby 
class BookInStock
  attr_reader :isbn, :price
  def initialize(isbn, price)
    @isbn = isbn
    @price = Float(price)
  end
end
```

> * Notar que se utilizan **símbolos**.
> * `attr_reader` **no define variables de instancia**, sólo los métodos de acceso.
</script></section><section data-markdown><script type="text/template">## Atributos de escritura

No sólo leemos atributos: a veces necesitamos modificar un valor. Ésto es
posible definiendo un método terminado con **el signo igual**.

```ruby
class BookInStock
  attr_reader :isbn, :price

  def initialize(isbn, price)
    @isbn = isbn
    @price = Float(price)
  end

  def price=(new_price)
    @price = new_price
  end
end
```
</script></section><section data-markdown><script type="text/template">## Atributos de escritura

```ruby
book = BookInStock.new("isbn1", 33.80)
book.price = book.price * 0.75 # discount price
puts "New price = #{book.price}"
```

<div class="container">

<div class="col small">

Podemos usar entonces:
* **`attr_writer`:** acceso W.
* **`attr_accessor`:** acceso RW.

</div>
<div class="col">


```ruby
class BookInStock

  attr_reader :isbn
  attr_accessor :price

  def initialize(isbn, price)
    @isbn = isbn
    @price = Float(price)
  end
end
```

</div>
</div></script></section><section data-markdown><script type="text/template">## Atributos virtuales

Agregamos el precio en centavos

<pre><code class="ruby hljs" data-trim data-line-numbers="10-16">
class BookInStock
  attr_reader :isbn
  attr_accessor :price
  def initialize(isbn, price)
    @isbn = isbn
    @price = Float(price)
  end

  def price_in_cents
    Integer(price*100 + 0.5)
  end

  def price_in_cents=(cents)
    @price = cents / 100.0
  end
end
</pre></code>
</script></section><section data-markdown><script type="text/template">## El lector de CSV
Ya tenemos el objeto que representa un libro. Resta implementar:
* Leer varios archivos CSV
* Totalizar ejemplares iguales
* Totalizar el precio de los libros en stock
</script></section><section data-markdown><script type="text/template">## CsvReader

Pensamos la estructura de `CsvReader`
```ruby
class CsvReader
  def initialize
  end

  def read_in_csv_data(csv_file_name)
  end

  def total_value_in_stock
  end

  def number_of_each_isbn
  end
end
```</script></section><section data-markdown><script type="text/template">## Uso de CsvReader

```ruby
reader = CsvReader.new
reader.read_in_csv_data("file1.csv")
reader.read_in_csv_data("file2.csv")
# Otros csv
puts "Total value in stock =  #{reader.total_value_in_stock}"
```

* Notamos que `CsvReader` debe ir acumulando lo que va leyendo de cada csv.
* Para ello mantendremos un arreglo de valores como variable de instancia.
* Para leer un CSV, Ruby provee de una librería que simplificará el trabajo.
</script></section><section data-markdown><script type="text/template">
## CsvReader

```ruby
require 'csv'

class CsvReader

  def initialize
    @books_in_stock = []
  end

  def read_in_csv_data(csv_file_name)
    CSV.foreach(csv_file_name, headers: true) do |row|
      @books_in_stock << 
        BookInStock.new(row["ISBN"], row["Amount"])
    end
  end
end
```
> Utilizamos la librería `csv` que nos permite acceder a los campos de cada
> columna por su nombre.
</script></section><section data-markdown><script type="text/template">## Cálculo  del precio total

```ruby
class CsvReader

  def total_value_in_stock
    sum = 0.0
    @books_in_stock.each do |book| 
      sum += book.price
    end
    sum
  end

end
```

> Ya veremos una implementación **más rubista** que la utilizada en esta
> instancia.
</script></section><section data-markdown><script type="text/template">
## Organizando el código

* Dividimos el código en tres archivos
  * **`lib/book_in_stock.rb`:** la clase `BookInStock`
  * **`lib/csv_reader.rb`:** el código de `CsvReader`
  * **`stock_stats.rb`:** el programa principal
* Aparecerán dependencias entre ellos
  * Para cargar dependencias externas se utiliza: **`require`** y **`require_relative`**
</script></section><section data-markdown><script type="text/template">
### stock_stats.rb

```ruby
require_relative 'csv_reader'

reader = CsvReader.new
ARGV.each do |csv_file_name|
  STDERR.puts "Processing #{csv_file_name}"
  reader.read_in_csv_data(csv_file_name)
end

puts "Total value = #{reader.total_value_in_stock}"
```

[Descargar el
ejemplo](https://github.com/chrodriguez/ttps-ruby/tree/master/ejemplos/stock-stats)


</script></section></section><section ><section data-markdown><script type="text/template">
# Clases y variables

<div class="main-list">

* ruby

</div>
</script></section><section data-markdown><script type="text/template">
# Clases
</script></section><section data-markdown><script type="text/template">## Control de acceso

* Permitir demasiado acceso en las clases incrementará el **acoplamiento** de
  la aplicación: _los usuarios de una clase que se expone demasiado podrían confiar en
    detalles de implementación en vez de su interfaz lógica._
* Ruby provee control de acceso a los métodos
* Una regla importante es: **_Nunca exponer métodos que puedan dejar un objeto
  en estado inválido_**.
</script></section><section data-markdown><script type="text/template">
## Niveles de protección
* **Públicos:** los métodos públicos pueden invocarse por cualquiera. Los
  métodos son públicos por defecto excepto `initialize` que es privado.
* **Protegidos:** pueden invocarse por objetos de la clase que lo define y
  subclases.
* **Privados:** no pueden ser invocados con un receptor explícito:
  _el receptor es siempre el objeto actual, `self`_. Esto
  significa que tampoco puede invocar el método privado de otra instancia de la
  misma clase.
</script></section><section data-markdown><script type="text/template">## Aplicando accesos

```ruby
class MyClass
  def method  # default is public
  end

  protected   # subsequent methods will be 'protected'
  def method2
  end

  private     # subsequent methods will be 'private'
  def method3
  end

  public      # subsequent methods will be 'public'
  def method4
  end
end
```</script></section><section data-markdown><script type="text/template">## Alternativamente

```ruby
class MyClass
  def method1; end
  def method2; end
  def method3; end
  def method4; end

  public :method1, :method4
  protected :method2
  private :method3
end
```
</script></section><section data-markdown><script type="text/template">
# Variables
</script></section><section data-markdown><script type="text/template">## Variables
* Hemos usado variables en varias oportunidades.
* Se usan para no perder valores y poder referenciarlos nuevamente.
* Cada variable es una **referencia** a un objeto.

> *Is a variable an object?* ***In Ruby, the answer is no.*** *A variable is simply a
> reference to an object. Objects float around in a big pool somewhere (the heap, most of the
> time) and are pointed to by variables.*
</script></section><section data-markdown><script type="text/template">
## Son referencias

Analicemos el siguiente ejemplo

```ruby
person1 = "Tim"
person2 = person1
person1[0] = 'J'
puts "person1 is #{person1}"
puts "person2 is #{person2}"
```

### Para evitarlo: `dup`

```ruby
person1 = "Tim"
person2 = person1.dup
person1[0] = 'J'
puts "person1 is #{person1}"
puts "person2 is #{person2}"
```</script></section><section data-markdown><script type="text/template">
## Freezando un objeto

Es posible freezar objetos

```ruby
person1 = "Tim"
person2 = person1
person1.freeze
person2[0] = 'J'
```



</script></section></section><section ><section data-markdown><script type="text/template">
# Colecciones

<div class="main-list">

* ruby

</div>
</script></section><section data-markdown><script type="text/template">
## Introducción
* Las colecciones representan elementos fundamentales de cualquier programa.
* Ruby provee dos clases que representan colecciones:
  * `array`
  * `hash` _o  arreglo asociativo_
* El correcto uso de estas colecciones es fundamental en la programación Ruby.
* Los bloques, combinados con colecciones se convierten en construcciones muy
  poderosas para la iteración.
</script></section><section data-markdown><script type="text/template">
## Array

<div class="container">
  <div class="col">

* La clase `Array` mantiene una colección de referencias a objetos.
* Cada referencia a objeto ocupa una posición en el arreglo, identificada por un
  índice entero no negativo.

  </div>
  <div class="col">

```ruby
a = [ 3.14159, "pie", 99 ]
a.class
a.length
a[0]
a[1]
a[2]
a[3]

b = Array.new
b.class
b.length
b[0] = "second"
b[1] = "array"
```
  </div>
</div>
</script></section><section data-markdown><script type="text/template">
## Arrays y `[]`

* Los elementos de un arreglo se acceden con el operador `[]`.
* Pero `[]` es un método (de instancia en la clase `Array`) y por tanto puede
  implementarse por cualquier subclase.
* El primer índice de un arreglo es el cero.
* Un arreglo accedido en un índice positivo retorna el objeto referenciado en
  esa posición.
  * Si no hay objeto, retorna `nil`.
* Un arreglo accedido en un índice negativo, retorna el objeto contando desde el
  final.
</script></section><section data-markdown><script type="text/template">## Uso de índices

<div class="container">
  <div class="col">

### Negativos

```ruby
a = [ 1, 7, 9]
a[-1]
a[-2]
a[-99]


```

  </div>
  <div class="col">

### Pares
```ruby
a = [ 1, 3, 5, 7, 9 ]
a[1, 3]
a[3, 1]
a[-3, 2]


```

> El significado es `[desde,cantidad]`

  </div>
  <div class="col">

### Rangos

```ruby
a = [ 1, 3, 5, 7, 9]
a[1..3]
a[1...3]
a[3..3]
a[-3..-1]
```
> Significa **desde** y **hasta**.
> Si se utiliza `..` se incluye el fin de rango, con
> `...` se **excluye** el extremo final.
  </div>
  </div>
</script></section><section data-markdown><script type="text/template">## El método `[]=`


Setea elementos de un array.

```ruby
a = [ 1, 3, 5, 7, 9 ]
a[1] = 'bat'
a[-3] = 'cat'
a[3] = [ 9, 8 ]
a[6] = 99
```

> Si se utiliza un único índice, reemplaza su valor por lo que esté
> a la derecha de la asignación: _cualquier gap que haya quedado luego de `[]=`
> se completa con nil._
</script></section><section data-markdown><script type="text/template">## El método `[]=`
* Utilizando dos valores o un rango, el comportamiento depende de lo que 
  esté a la derecha de la asignación:
  * Si la cantidad  a reemplazar es cero, entonces **inserta el valor**
    en la posición inicial: **_no se eliminan elementos_**.
  * Si el valor a la **derecha es un arreglo**, sus elementos se utilizan en el 
    reemplazo: _el tamaño del arreglo es actualizado si la cantidad de
    elementos a la derecha difiere de la cantidad a reemplazar._
</script></section><section data-markdown><script type="text/template">## Mejor un ejemplo


```ruby
a = [ 1, 3, 5, 7, 9 ]
a[2, 2] = 'cat'
a[2, 0] = 'dog'
a[1, 1] = [ 9, 8, 7 ]
a[0..3] = []
a[5..6] = 99, 98
```
</script></section><section data-markdown><script type="text/template">## push y pop


```ruby
stack = []
stack.push "red"
stack.push "green"
stack.push "blue"

puts stack.pop
puts stack.pop
puts stack.pop
```
</script></section><section data-markdown><script type="text/template">## shift y unshift

```ruby
stack = []
(stack.unshift 1).unshift 2
stack.unshift 3

puts stack.shift
puts stack.shift
puts stack.shift
```
</script></section><section data-markdown><script type="text/template">## first y last

```ruby
array = [ 1, 2, 3, 4, 5, 6, 7 ]
p array.first(4)
p array.last(4)
```
</script></section><section data-markdown><script type="text/template">## Hashes

* Los arreglos se indexan con enteros, los hashes con objetos: _Símbolos, strings, expresiones regulares, etc_.
* Cuando se almacena un valor en un hash, utilizamos:
  * El índice, generalmente llamado *key*
  * El dato a almacenar en dicho índice, generalmente llamado *valor*
* El acceso a los valores referenciados por un hash se realiza por medio de los
  *keys*.
</script></section><section data-markdown><script type="text/template">
### Ejemplo

```ruby
h = { 'dog' => 'canine', 'cat' => 'feline' }
h.length # => 2
h['dog'] # => "canine"
h['cow'] = 'bovine'
h[12] = 'dodecine'
h['cat'] = 99
```
</script></section><section data-markdown><script type="text/template">### Cambio de notación

```ruby
# En ruby >= 1.9
h = { dog: 'canine', cat: 'feline' }

# En ruby < 1.9
h = { :dog => 'canine', :cat => 'feline' }
```</script></section><section data-markdown><script type="text/template">
### Un programa usando colecciones


Calcular el número de veces que aparece una palabra en un texto

> El problema se divide en dos partes:
> * Separar el texto en palabras: *suena como un array*
> * Luego contar cada palabra diferente: *suena como hash*
</script></section><section data-markdown><script type="text/template">
### El método que obtiene las palabras

Usando expresiones regulares y el método `scan` todo parece muy simple:

```ruby
def words_from_string(string)
  string.downcase.scan(/[\w']+/)
end
```</script></section><section data-markdown><script type="text/template">### El método que cuenta las palabras

Con un hash indexaremos para cada palabra, la cantidad de ocurrencias.

```ruby
if counts.has_key?(next_word)
  counts[next_word] += 1
else
  counts[next_word] = 1
end
```
</script></section><section data-markdown><script type="text/template">
## Refactorizamos

```ruby
def count_frequency(word_list)
  counts = Hash.new(0)
  for word in word_list
    counts[word] += 1
  end
  counts
end
```

> `Hash.new` puede recibir como parámetro el valor usado para incializar cada
> valor del Hash
> [Descargar ejemplo](https://github.com/chrodriguez/ttps-ruby/tree/master/ejemplos/words-frequency)


</script></section></section><section ><section data-markdown><script type="text/template">
# Bloques e iteradores

<div class="main-list">

* ruby

</div>
</script></section><section data-markdown><script type="text/template">
## Bloques
* Un bloque es código encerrado entre llaves o las palabras claves `do` y `end`
* Ambas formas son idénticas, salvo por la precedencia
  * Cuando el código del bloque entra en una línea usar {}
  * Cuando tiene más de una línea usar `do` / `end`
* Los bloques pueden verse como métodos anónimos
</script></section><section data-markdown><script type="text/template">
## Bloques
* Pueden recibir parámetros, que se explicitan entre barras verticales `|`
* El código de un bloque no se ejecuta cuando se define, sino que se almacenará
  para ser ejecutado más adelante
* En ruby, los bloques sólo podrán usarse después de la *invocación* de algún
  método
  * Si el método recibe parámetros, entonces aparecerá luego de ellos
  * Podría verse incluso como un parámetro extra que es pasado al método
</script></section><section data-markdown><script type="text/template">
## Ejemplo

Suma de los cuadrados de los números en un arreglo

<div class="container">
<div class="col">

```ruby
sum = 0
[1, 2, 3, 4].each do |value|
  square = value * value
  sum += square
end
puts sum
```

</div>
<div class="col small">

* El bloque se invoca para cada elemento en el arreglo
* El elemento del arreglo es pasado al bloque en la variable `value`
* La variable `sum` declarada fuera del bloque es actualizada dentro del bloque
</div>
</div>
</script></section><section data-markdown><script type="text/template">## Bloques

* **Regla importante:** *si existe una variable en el bloque con el mismo
  nombre que una variable dentro del alcance pero creada fuera del bloque, ambas serán la
  misma variable. En el ejemplo hay sólo una variable `sum`*
* Veremos que el comportamiento mencionado podremos cambiarlo
* Si una variable aparece sólo en el bloque, entonces será local al mismo (como
`square`)
</script></section><section data-markdown><script type="text/template">## Un caso inesperado

```ruby
# assume Shape defined elsewhere
square = Shape.new(sides: 4) 
#
# .. lots of code
#
sum = 0
[1, 2, 3, 4].each do |value|
  square = value * value
  sum += square
end

puts sum
square.draw # BOOM!
```
</script></section><section data-markdown><script type="text/template">## Mas casos

No sucede lo mismo con los argumentos al bloque

```ruby
value = "some shape"
[ 1, 2 ].each {|value| puts value }
puts value
```

Podemos solucionar el problema de `square`

```ruby
square = "some shape"
sum = 0
[1, 2, 3, 4].each do |value; square|
  square = value * value # different variable
  sum += square
end
puts sum
puts square
```
</script></section><section data-markdown><script type="text/template">## La magia de los bloques

<div class="small">

* Mencionamos que los bloques se utilizan de forma adyacente a la llamada a un
  método y que no se ejecutan en el momento en que aparecen en el código
* Para lograr este comportamiento, dentro de un método cualquiera, podremos
  invocar un bloque
  * Los bloques se invocarán como si fueran métodos
  * Para invocar un bloque se utiliza la sentencia `yield`
  * Al invocar `yield` ruby invocará al código del bloque 
  * Cuando el bloque finaliza, ruby devuelve el código inmediatamente al
    finalizar el llamado a `yield`
</div></script></section><section data-markdown><script type="text/template">## Ejemplo de un bloque

```ruby

def three_times
  yield
  yield
  yield
end

three_times { puts "Hola" }
```
</script></section><section data-markdown><script type="text/template">
## Parámetros a un bloque

* Cuando utilizamos `yield` podemos enviarle un parámetro
  * El parámetro enviado se mapea con el definido en el bloque entre las barras
    verticales
* Un bloque puede retornar un valor y ser usado en el método
</script></section><section data-markdown><script type="text/template">## Ejemplo de envío de parámetros

```ruby

def fib_up_to(max)
  i1, i2 = 1, 1
  while i1 <= max
    yield i1
    i1, i2 = i2, i1+i2
  end
end

fib_up_to(1000) {|f| print f, " " }

```
</script></section><section data-markdown><script type="text/template">## Uso del valor retornado

```ruby

class Array
  def my_find
    for i in 0...size
      value = self[i]
      return value if yield(value)
    end
    return nil
  end
end

(1..200).to_a.my_find {|x| x%5 == 0}

(1..200).to_a.my_find {|x| x == 0}

```
</script></section><section data-markdown><script type="text/template">## Los iteradores
* Las clases que implementan colecciones, como `Array` *hacen lo que hacen
  mejor:*
  * Acceder a los elementos que contienen
* El comportamiento de qué hacer con cada elemento lo delegan a la aplicación
  * Permitiendo que nos concentremos sólo en un requerimiento particular
  * En los casos anteriores (`find`), sería encontrar un elemento para el cual
    el criterio sea verdadero
</script></section><section data-markdown><script type="text/template">## each y collect

* El iterador `each` es el más simple 
  * Solo invoca `yield` para cada elemento
* El iterador `collect` también conocido como `map` 
  * Invoca `yield` para cada elemento. El resultado lo guarda en un nuevo 
  arreglo que es **retornado**

```ruby
[ 1, 3, 5, 7, 9 ].each {|i| puts i }

['k','h','m','t','w'].collect {|x| x.succ }
```
</script></section><section data-markdown><script type="text/template">## Otros usos de iteradores 

* Los iteradores no sólo se usan con array y hash
* Su lógica es muy utilizada en clases de entrada / salida para retornar
  líneas sucesivas o bytes

```ruby
f = File.open("testfile")
f.each { |line| puts "The line is: #{line}"}
f.close
```


```ruby
f = File.open("testfile")
f.each_with_index do |line, index| 
  puts "Line #{index} is: #{line}" 
end
f.close
```
</script></section><section data-markdown><script type="text/template">## inject
* Este iterador tiene un nombre *raro*
* Permite acumular un valor a lo largo de los miembros de una colección
* Recibe un parámetro que es el valor inicial para comenzar a acumular
  * Si no se especifica **toma el primer elemento de la colección**

```ruby
[1,3,5,7].inject(0) {|sum, element| sum+element}
[1,3,5,7].inject    {|sum, element| sum+element}
[1,3,5,7].inject(1) {|prod, element| prod*element}
[1,3,5,7].inject    {|prod, element| prod*element}
```
</script></section><section data-markdown><script type="text/template">## inject

Un uso más críptico de `inject`:

```ruby
[1,3,5,7].inject(:+)
[1,3,5,7].inject 100, :+
[1,3,5,7].inject(:*)
```
</script></section><section data-markdown><script type="text/template">## Problema de iteradores
* Los iteradores son muy cómodos pero:
  * Son parte de la colección y no una clase a parte
  * En otros lenguajes (como Java), las colecciones no implementan sus
    iteradores, sino que son clases separadas (como por ejemplo la interfaz 
    Iterator de Java)
  * Es complicado iterar dos colecciones simultáneamente
</script></section><section data-markdown><script type="text/template">## Enumerators

* La solución: clase `Enumerator`
* Se obtiene de una colección con el método `to_enum` o `enum_for`

```ruby
a = [ 1, 3, "cat" ]
h = { dog: "canine", fox: "lupine" }
# Create Enumerators
enum_a = a.to_enum
enum_h = h.to_enum
enum_a.next   # => 1
enum_h.next   # => [ :dog, "canine" ]
enum_a.next   # => 3
enum_h.next   # => [ :fox, "lupine" ]
```</script></section><section data-markdown><script type="text/template">## Enumerators e iteradores

Si un iterador se utiliza sin bloque, entonces retorna un Enumerator

```ruby
a = [1,2,3].each
a.next
```
</script></section><section data-markdown><script type="text/template">## El método loop
<div class="small">

* Ejecuta el código que se encuentra dentro del bloque
* Se puede salir con break cuando se cumple una condición
* Si hay iteradores, `loop` terminará cuando el Enumerator se quede sin valores

</div>

<div class="container">
<div class="col">

```ruby


loop { puts "Hola" }



```
</div>
<div class="col">

```ruby
i=0
loop do
  puts i += 1
  break if i >= 10
end
```
</div>
</div>

```ruby
short_enum = [1, 2, 3].to_enum
long_enum = ('a'..'z').to_enum
loop { puts "#{short_enum.next} - #{long_enum.next}" }
```
</script></section><section data-markdown><script type="text/template">## Enumerator como objeto

Sabemos que es posible usar `each_with_index` en `Array`

```ruby
result = []
[ 'a', 'b', 'c' ].each_with_index do |item, index| 
  result << [item, index] 
end
```

<div class="fragment">

¿Y si queremos hacer lo mismo con un `String`?
</div>

<div class="fragment small">

* No existe `each_with_index` en `String`
* Pero sí existe `each_char` que es como `each` de `Array` pero sobre cada
  caracter del string
  * Si no enviamos un bloque, retornará un `Enumerator`
* La interfaz `Enumerable` define el método `each_with_index`
</div>
</script></section><section data-markdown><script type="text/template">## El código con String
```ruby
result = []
"cat".each_char.each_with_index do |item, index| 
    result << [item, index] 
end
# Aun más simple:
result = []
"cat".each_char.with_index do |item, index| 
    result << [item, index] 
end
```
</script></section><section data-markdown><script type="text/template">## Enumerator como generadores
<div class="small">

* Podemos crear objetos enumerator explícitamente en vez de hacerlo a partir de
  una colección
* Para ello es necesario utilizar un bloque en la creación
  * El código del bloque se usará por el objeto Enumerator cada vez que el
    programa principal le solicite un nuevo valor
  * Este bloque no se ejecutará como otros bloques dado que su ejecución
    se disparará cada vez que se solicita el siguiente valor
  * La ejecución del bloque se pausa y vuelve al programa principal cuando se
    encuentra `yield`
  * Cuando se solicita el siguiente valor, el código del bloque continúa a
    partir de la línea siguiente al `yield`
</div>
</script></section><section data-markdown><script type="text/template">## Enumerator como generadores
Generamos **secuencias infinitas**:


```ruby
fibonacci = Enumerator.new do |caller|
  i1, i2 = 1, 1
  loop do
    caller.yield i1
    i1, i2 = i2, i1+i2
  end
end

6.times { puts fibonacci.next }
```

<div class="small">

Como `Enumerator` es `Enumerable` sería posible:
</div>

```ruby
fibonacci.first(1000).last
```
</script></section><section data-markdown><script type="text/template">## ¡Hay que tener cuidado!

<div class="small">

* Cuidado con los enumerators que generan listas infinitas
* Los metodos comunes de los enumeradores como `count` y `select` tratarán de
  leer todos los elementos antes de retornar un valor
  * Podemos escribir la versión de `select` adecuada a nuestra lista
    infinita

</div>

```ruby
def infinite_select(enum, &block)
  Enumerator.new do |caller|
    enum.each do |value|
      caller.yield(value) if block.call(value)
    end
  end
end

p infinite_select(fibonacci) {|val| val % 2 == 0}.first(5)
```
</script></section><section data-markdown><script type="text/template">## Solución conveniente
Podemos escribir filtros como `infinite_select` directamente en la clase
`Enumerator`

``` ruby
class Enumerator
  def infinite_select(&block)
    Enumerator.new do |caller|
      self.each do |value|
        caller.yield(value) if block.call(value)
      end
    end
  end
end

p fibonacci.
  infinite_select {|val| val % 2 == 0}.
  infinite_select {|val| val.to_s =~ /13\d$/ }.
  first(2)
```
</script></section><section data-markdown><script type="text/template">## Bloques como transacciones

<div class="small">

* Podemos usar bloques para definir código que debe ejecutarse bajo ciertas
  condiciones transaccionales.
* Por ejemplo:
  * Abrir un archivo
  * Procesarlo
  * Cerrarlo
* Si bien esto podemos hacerlo secuencialmente, utilizando bloques simplificamos
  mucho 
</div>

```ruby
class File
  def self.open_and_process(*args)
    f = File.open(*args)
    yield f
    f.close()
  end
end
```
</script></section><section data-markdown><script type="text/template">## Analizamos un poco...

<div class="small">

* El método de clase implementado fue desarrollado para que entienda los mismos
  parámetros que `File.open` 
* Para ello, lo que hicimos es pasar los parámetros tal cual se enviaron a
  `File.open`
  * Esto se logra definiendo como argumento al método `*args` que significa:
    *tomar todos los argumentos enviados al método actual y colocarlos en un
    arreglo llamado args*
  * Luego llamamos a `File.open(*args)`. Utilizar *args vuelve a expandir los
    elementos del arreglo a parámetros individuales
</div>
</script></section><section data-markdown><script type="text/template">## Versión completa de my_open
```ruby
class File
  def self.my_open(*args)
    result = file = File.new(*args)
    if block_given?
      result = yield file
      file.close
    end
    return result
  end
end
```


> Esta técnica es tan útil, que `File.open` ya lo implementa.  Además de usar `File.open`
> para abrir un archivo, podemos usarlo para directamente procesarlo como lo hacíamos
> con `open_and_process`
</script></section><section data-markdown><script type="text/template">## Bloques como objetos
* Anteriormente mencionamos que los bloques son como un parámetro
  adicional pasado a un método
* Podremos forzar bloques como parámetros explícitos
  * Utilizando & en el último parámetro, Ruby buscará el codigo
    de un bloque cuando el método es invocado
  * Este parámetro podrá utilizarse como cualquier otro
</script></section><section data-markdown><script type="text/template">## Bloques como objetos

```ruby
class ProcExample
  def pass_in_block(&action)
    @stored_proc = action
  end
  def use_proc(parameter)
    @stored_proc.call(parameter)
  end
end

eg = ProcExample.new
eg.pass_in_block { |param| puts "The parameter is #{param}" }
eg.use_proc(99)
```</script></section><section data-markdown><script type="text/template">
## Avanzando un poco más...
* Vemos que `call` invoca la ejecución del bloque 
* Muchos programas utilizan esta idea para implementar **callbacks**
* ¿Qué pasaría si retornamos el bloque?

```ruby
def create_block_object(&block)
  block
end

bo = create_block_object do |param| 
  puts "You called me with #{param}"
end
bo.call 99
bo.call "cat"
```
</script></section><section data-markdown><script type="text/template">## Proc y lambda
* Devolver un bloque es tan útil que en Ruby hay dos formas de hacerlo:
  * `lamda` y `Proc.new` toman un bloque y retornan un objeto
  * El objeto retornado es de la clase `Proc`
  * La diferencia entre `lambda` y `Proc.new` la veremos más adelante, pero ya
    hemos mencionado que `lambda` controla los parámetros que requiere el
    bloque, mientras que `Proc` no lo hace
</script></section><section data-markdown><script type="text/template">## Bloques como Closures
* Recordamos haber mencionado que los bloques pueden utilizar variables que
  están dentro del alcance del bloque
* Veremos ahora un uso diferente de un bloque haciendo esto

```ruby
def n_times(thing)
  lambda {|n| thing * n }
end
p1 = n_times(10)
p1.call(3)
p1.call(4)
p2 = n_times("Hola ")
p2.call(3)
```
</script></section><section data-markdown><script type="text/template">## ¿Qué es un Closure?
* El método `n_times` referencia el parámetro `thing` que es usado por el bloque
* Aunque en las llamadas a `call` (y por ende en la ejecución del bloque) el 
  parámetro `thing` está fuera del alcance, el parámetro se mantiene accesible
  dentro del bloque
* Esto es un closure:
  * Variables en el alcance cercano que son referenciadas por el bloque se
    mantienen accesibles por la vida del bloque y la vida del objeto Proc creado
    para este bloque
</script></section><section data-markdown><script type="text/template">## Otro ejemplo de Closure

```ruby
def what_do_i_do?
  value = 1
  lambda { value += value }
end

let_me_see = what_do_i_do?
let_me_see.call
let_me_see.call
```
</script></section><section data-markdown><script type="text/template">## Notación alternativa

```ruby
lambda { |params| ... }
# es equivalente a
->params { ... }

# Y con parámetros
proc1 = -> arg {puts "proc1:#{arg}" }
proc2 = -> arg1, arg2 {puts "proc2:#{arg1} y #{arg2}" }
proc3 = ->(arg1, arg2) {puts "proc3:#{arg1} y #{arg2}" }

proc1.call "ant"
proc2.call "bee", "cat"
proc3.call "dog", "elk"
```
</script></section><section data-markdown><script type="text/template">## Custom while
Reimplementamos un while usando bloques

```ruby
def my_while(cond, &body)
  while cond.call
    body.call
  end
end

a = 0
my_while -> { a < 3 } do
  puts a
  a += 1
end
```
</script></section><section data-markdown><script type="text/template">### Lista de parámetros a un bloque
* Los argumentos a un bloque podrán ser:
  * Argumentos splat
  * Inicializados con un valor por defecto
  * Bloques como parámetro (usando &)</script></section><section data-markdown><script type="text/template">### Lista de parámetros a un bloque
```ruby
proc1 = lambda do |a, *b, &block|
  puts "a = #{a.inspect}"
  puts "b = #{b.inspect}"
  block.call
end
proc1.call(1, 2, 3, 4) { puts "in block1" }

proc2 = -> a, *b, &block do
  puts "a = #{a.inspect}"
  puts "b = #{b.inspect}"
  block.call
end
proc2.call(1, 2, 3, 4) { puts "in block2" }
```
</script></section><section data-markdown><script type="text/template">### El símbolo usado como bloque

Para entender por qué funciona:

```ruby
[1,2,3].inject &:+
```

<div class="small"> 

Analizando qué es lo que sucede en el siguiente ejemplo
</div>

```ruby
o = Object.new
[1,2,3].inject &o
# Esto da un error: TypeError: wrong argument type Object (expected Proc)
```
</script></section><section data-markdown><script type="text/template">### El símbolo usado como bloque

Que se soluciona con:
</div>

```ruby
class Object
  def to_proc
    Proc.new {}
  end
end
```</script></section><section data-markdown><script type="text/template">### El símbolo usado como bloque

Analizando entonces lo que sucedió inferimos que la clase `Symbol` implementa
`#to_proc` de la siguiente forma:

```ruby
class Symbol
  def to_proc
    lambda { |obj| obj.send(self) }
  end
end
```

<div class="small">

El ejemplo `[1,2,3].map &:to_s ` ¡funciona perfecto!

**Pero no funciona `[1,2,3].inject &:+`**
</div></script></section><section data-markdown><script type="text/template">### El símbolo usado como bloque

Tratamos de solucionar la implementación anterior:

```ruby
class Symbol
  def to_proc
    lambda { |obj, args| obj.send(self, *args) }
  end
end
```
<div class="small">

El ejemplo `[1,2,3].inject &:+` ¡funciona pefecto!

**Pero no funciona `[1,2,3].map &:to_s`**
</div></script></section><section data-markdown><script type="text/template">### El símbolo usado como bloque

La solución a ambos problemas:

```ruby
class Symbol
  def to_proc
    lambda { |obj, args=nil| obj.send(self, *args) }
  end
end
```



</script></section></section></div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"transition":"slide"}, queryOptions);
    </script>

    <script src="./_assets/src/js/clipboard.min.js"></script>
    <script src="./_assets/node_modules/reveal.js-copycode/plugin/copycode/copycode.js"></script>
    <script src="./_assets/src/js/custom.js"></script>

    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
